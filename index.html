<html>
    <head>
        <title>Homepage</title>
        <link rel="stylesheet" type="text/css" href="styles.css" />
        <meta charset="utf-8"/>
        <meta name="viewpoint" content="width=device-width, initial-scale=1.0"/>
        <meta http-equiv="X-UA-Compatible" content="ie=edge"/>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script>

        //Functii javascript

          $(document).ready(function(){

            //1) Ascunde toate elementele de tip textbox si afiseaza doar elementul cu id-ul "start"
            $(".textbox").hide();
            $("#start").show();

            //2) Schimba continutul elementului Titlu cu continutul elementului de tip nav-link apast
            //3) Ascunde toate elementele de tip textbox si afiseaza elementul cu id-ul egal cu valoarea
            // variabilei value a elementului de tip .nav-link apaast
            $('.nav-link').on('click',(function(){
              var ttl=$(this).first().text();
              $(".Header-Title").text(ttl);

              var inputValue = $(this).attr("value");
              var targetBox = $("#"+inputValue);
              $(".textbox").not(targetBox).hide();
              $(targetBox).show();
            }));
          });

          $(document).ready(function(){

            //4)) Functie folosita in meniul de navigare. Afiseaza elementele ascunse corespunzatoare elementului de tip has-sub apasat
            $('.has-sub').on('click', function(){
              $(this).parent().toggleClass('tap');
            });
          });
        </script>
        <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
    </head>
    <body>
       <div class="wrapper">
         <div class="capsule">

           <!-- Header-ul -->
           <section class="header">
             <div class="Titlu">
              <h1 class="Header-Title">Teoria Grafurilor</h1>
             </div>
            </section>

            <!-- Meniul de navigare -->

            <!-- Sidebar-ul -->
           <section class="sidebar">
             <nav class="sidenav">
               <ul class="nav-links">
                 <li><a class="has-sub">Grafuri Neorientate<span class="sub-arrow"></span></a>
                   <ul>
                    <li class="nav-link" value="TGN"><a>Teorie Grafuri Neorientate</a></li>
                    <li class="nav-link" value="PGN"><a>Parcurgerea Grafurilori Neorientate</a></li>
                   </ul>
                 </li>
                 <li><a class="has-sub">Grafuri Orientate<span class="sub-arrow"></span></a>
                   <ul>
                     <li class="nav-link" value="TGO"><a>Teorie Grafuri Orientate</a></li>
                     <li class="nav-link" value="TC"><a>Graf Tare Conex. Componente Tare Conexe</a></li>
                     <li class="nav-link" value="MD"><a>Matricea Drumurilor. Algoritmul Roy-Warshall</a></li>
                   </ul>
                 </li>
                 <li><a  class="has-sub">Grafuri Ponderate<span class="sub-arrow"></span></a>
                  <ul>
                   <li class="nav-link" value="ARF"><a>Algoritmul Roy-Floyd</a></li>
                   <li class="nav-link" value="AD"><a>Algoritmul lui Dijkstra</a></li>
                   <li class="nav-link" value="AP"><a>Algoritmul lui Prim</a></li>
                   <li class="nav-link" value="AK"><a>Algoritmul lui Kruskal</a></li>
                  </ul>
                  </li>
                 <li class="nav-link" value="AR"><a>Arbori cu Radacina</a></li>
               </ul>
             </nav>
           </section>

           <!-- Continutul principal al paginii -->
           <section class="main">


            <div class="textbox" id="start">
               <p>Grafurile au numeroase aplicații în diverse domenii: proiectarea circuitelor electrice, determinarea celui mai scurt drum dintre două localități, rețelele sociale (ex. Facebook), etc.
               </p>
               <p>Primele rezultate legate de teoria grafurilor au fostobținute de matematicianul Leonard Euler, cel care a studiat Problema podurilor din Königsberg, din imaginea de mai jos. A demonstrat că problema nu are soluție, iar în onoarea lui o categorie specială de grafuri au fost numite grafuri euleriene.
               </p>
               <img src="konigsberg.jfif" style="width:100%; height:auto; margin-left:5px;">
             </div>


            <div class="textbox" id="TGN">
              <h1>Terminologie</h1>
                <p><b>Definiție</b>: Se numește <b>graf neorientat</b> o pereche ordonată de mulțimi <i>G=(X,U)</i>, unde:</p>
                <p class="indented"><i>X</i> este o mulțime finită și nevidă de elemente numite <b>vârfuri</b> sau <b>noduri</b>;</p>
                <p class="indented"><i>U</i> este o mulțime finită de submulțimi cu două elemente din <i>X</i>, numite <b>muchii</b>.</p>
                <p>Vom nota în continuare vârfurile cu valori între <i>1</i> și <i>n</i> – unde n este număru de vârfuri din graf, iar muchiile cu <i>[x,y]</i> sau <i>(x,y)</i>, unde <i>x</i> și y sunt vârfuri și se numesc <b>extremitățile</b> muchiei.</p>
                <p>Un <b>vecin</b> al unui vârf <i>x</i> este orice vârf <i>y</i> cu proprietatea că există muchia <i>[x,y]</i>.
                </p>
                <p>Două vârfuri între care există muchie se numesc <b>adiacente</b>.
                </p>
                <p>Două muchii sunt <b>incidente</b> dacă au o o extremitate comună. Un vârf este <b>incident</b> cu o muchie dacă vârful este extremitate a acelei muchii.
                </p>
                <p>Mulțimea muchiilor are proprietatea de simetrie: dacă <code>[x,y]</code> este muchie, atunci și <code>[y,x]</code> este muchie.</p>
                <p>Conform definiției:</p>
                <p class="indented">&icirc;ntr-un graf neorientat nu există muchie de la un v&acirc;rf la el &icirc;nsuși;</p>
                <p class="indented">intre două v&acirc;rfuri distincte există cel mult o muchie.<p>
                <p><strong>Exemplu:</strong> Fie <code>G=(X,U)</code>, unde:</p>
                <p class="indented"><code>X={1,2,3,4,5,6,7,8,9,10,11}</code></p>
                <p class="indented"><code>U={[1,4],[1,5],[2,3],[2,8],[3,11],[4,5],[4,9],[7,10],[8,11]}</code></p>
                <img src="graf-neorientat.png">
              <h1>Gradul unui vârf</h1>
                <p><strong>Definiție</strong> &Icirc;ntr-un graf neorientat se numește <strong>grad</strong> al unui v&acirc;rf numărul de v&acirc;rful adiacente cu acesta (sau numărul de muchii incidente cu acesta). Gradul unui vărf <code>x</code> se notează <code>d(x)</code> (<em>degree</em>).</p>
                <p><strong>Observații:</strong></p>
                <p class="indented">un v&acirc;rf cu gradul <code>0</code> se numește <strong>izolat</strong>. &Icirc;n graful de mai sus, v&acirc;rful <code>6</code> este izolat.</p>
                <p class="indented">un v&acirc;rf cu gradul <code>1</code> se numește <strong>terminal</strong>. &Icirc;n graful de mai sus, v&acirc;rful <code>9</code> este v&acirc;rf terminal.</p>
                <p class="indented">gradul maxim al unui v&acirc;rf &icirc;ntr-un graf cu <code>n</code> v&acirc;rfuri este <code>n-1</code>.</p>
                <p><strong>Teoremă:</strong>&nbsp;&Icirc;ntr-un graf neorientat, suma gradelor tuturor v&acirc;rfurilor este dublul numărului de muchii.</p>
                <p><strong>Consecințe:</strong></p>
                <p class="indented">Suma gradelor tuturor v&acirc;rfurilor este număr par.<p>
                <p class="indented">&Icirc;ntr-un graf neorientat, numărul de v&acirc;rfuri de grad impar este &icirc;ntotdeauna par.<p>
                <p><strong>&Icirc;ntrebare:</strong>&nbsp;Este posibil ca &icirc;ntr-un grup de&nbsp;<code>5</code>&nbsp;persoane, fiecare persoană să aibă exact&nbsp;<code>3</code>&nbsp;prieteni?</p>
              <h1>Reprezentarea grafurilor neorientate</h1>
                <h2>Matricea de adiacență</h2>
                  <p>Pentru un graf neorientat&nbsp;<code>G=(X,U)</code>&nbsp;cu&nbsp;<code>n</code>&nbsp;v&acirc;rfuri, matricea de adiacență este o matrice cu&nbsp;<code>n</code>&nbsp;linii și&nbsp;<code>n</code>&nbsp;coloane și elemente din&nbsp;<code>{0,1}</code>, cu:</p>
                  $$
                  A_{i,j} = \left\{ \begin{array}{ll}
                  1 & \mbox{dacă } [i,j] \in U \\
                  0 & \mbox{dacă } [i,j] \notin U \end{array} \right.
                  $$
                  <p><strong>Exemplu:</strong>&nbsp;Pentru graful neorientat de mai jos avem următoarea matrice de adiacență:</p>
                  <img src="graf-neorientat-1.png">
                  $$
                  A = \left( \begin{array}{ccccc}
                  0 & 1 & 0 & 0 & 1 \\
                  1 & 0 & 0 & 0 & 1 \\
                  0 & 0 & 0 & 0 & 0 \\
                  0 & 0 & 0 & 0 & 1 \\
                  1 & 1 & 0 & 1 & 0 \end{array} \right)
                  $$
                  <p><strong>Observații:</strong></p>
                  <p class="indented">matricea de adiacență este simetrică față de diagonala principală;</p>
                  <p class="indented">elementele de pe diagonala principală sunt&nbsp;<code>0</code>;</p>
                  <p class="indented">gradul unui v&acirc;rf&nbsp;<code>x</code>&nbsp;este egal cu numărul de elemente&nbsp;<code>1</code>&nbsp;de pe linia (sau coloana)&nbsp;<code>x</code>;</p>
                  <p class="indented">suma tuturor elementelor din matricea de adiacență a unui graf neorientat este egală cu dublul numărului de muchii din graf.</p>
                <h2>Lista de muchii</h2>
                  <img src="graf-neorientat-1.png">
                  <p>Lista de muchii a unui graf neorientat reprezintă o mulțime ce conține toate muchiile din graf.</p>
                  <p>Pentru graful alăturat, lista de muchii este:</p>
                  <p><span id="MathJax-Element-3-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mrow&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-128" class="math"><span id="MathJax-Span-129" class="mrow"><span id="MathJax-Span-130" class="mi">U</span><span id="MathJax-Span-131" class="mo">=</span><span id="MathJax-Span-132" class="mrow"><span id="MathJax-Span-133" class="mo">{</span><span id="MathJax-Span-134" class="mrow"><span id="MathJax-Span-135" class="mo">[</span><span id="MathJax-Span-136" class="mn">1</span><span id="MathJax-Span-137" class="mo">,</span><span id="MathJax-Span-138" class="mn">2</span><span id="MathJax-Span-139" class="mo">]</span><span id="MathJax-Span-140" class="mo">,</span><span id="MathJax-Span-141" class="mo">[</span><span id="MathJax-Span-142" class="mn">1</span><span id="MathJax-Span-143" class="mo">,</span><span id="MathJax-Span-144" class="mn">5</span><span id="MathJax-Span-145" class="mo">]</span><span id="MathJax-Span-146" class="mo">,</span><span id="MathJax-Span-147" class="mo">[</span><span id="MathJax-Span-148" class="mn">2</span><span id="MathJax-Span-149" class="mo">,</span><span id="MathJax-Span-150" class="mn">5</span><span id="MathJax-Span-151" class="mo">]</span><span id="MathJax-Span-152" class="mo">,</span><span id="MathJax-Span-153" class="mo">[</span><span id="MathJax-Span-154" class="mn">4</span><span id="MathJax-Span-155" class="mo">,</span><span id="MathJax-Span-156" class="mn">5</span><span id="MathJax-Span-157" class="mo">]</span></span><span id="MathJax-Span-158" class="mo">}</span></span></span></span></span></p>
                  <p>Pentru reprezentarea &icirc;n memorie putem folosi:</p>
                  <p class="indented">un tablou unidimensional cu elemente de tip&nbsp;<code>struct {int I,J;}</code></p>
                  <p class="indented">două tablouri unidimensionale cu elemente de tip&nbsp;<code>int</code></p>
                  <p class="indented">o listă alocată dinamic</p>
                  <p class="indented">etc.</p>
                <h2>Liste de adiacențe (de vecini)</h2>
                  <img src="graf-neorientat-1.png">
                  <p>Pentru un graf neorientat cu&nbsp;<code>G=(X,U)</code>&nbsp;se va memora numărul de v&acirc;rfuri&nbsp;<code>n</code>&nbsp;și apoi, pentru fiecare v&acirc;rf&nbsp;<code>x</code>, lista v&acirc;rfurilor adiacente cu&nbsp;<code>x</code>, adică a v&acirc;rfurilor&nbsp;<code>y</code>&nbsp;cu proprietatea că există muchia&nbsp;<code>[x,y]</code>.</p>
                  <p>Pentru graful alăturat, listele de adiacență sunt:</p>
                  <pre contenteditable="true" style="font-size:20px;">
                    1: 2 5
                    2: 1 5
                    3: vidă
                    4: 5
                    5: 1 2 4
                  </pre>
                  <p>La reprezentarea &icirc;n memorie trebui avut &icirc;n vedere că dimensiunile listelor de vecini sunt variabile. De aceea, este neeficientă utilizarea unor tablouri alocate static. Astfel, putem folosi:</p>
                  <p class="indented">un șir de&nbsp;<code>n</code>&nbsp;tablouri unidimensionale alocate dinamic;</p>
                  <p class="indented">un șir de&nbsp;<code>n</code>&nbsp;vectori din&nbsp;<span class="caps">STL</span>;</p>
                  <p class="indented">un șir de&nbsp;<code>n</code>&nbsp;liste simplu (dublu) &icirc;nlănțuite alocate dinamic.</p>
                <h2>Graf parțial. Subgraf. Graf complementar</h2>
                  <p><strong>Definiție.</strong>&nbsp;Fie&nbsp;<code>G=(X, U)</code>&nbsp;un graf neorientat. Se numeşte&nbsp;<strong>graf parțial</strong>&nbsp;al grafului&nbsp;<code>G</code>, graful neorientat&nbsp;<code>G1=(X, U1)</code>, unde&nbsp;<code>U1 &sube; U</code>.</p>
                  <p>Din definiție rezultă:</p>
                  <p class="indented">Un graf parțial al unui graf neorientat&nbsp;<code>G=(V,U)</code>, are aceeaşi mulțime de v&acirc;rfuri ca şi&nbsp;<code>G</code>, iar mulțimea muchiilor este o submulțime a lui&nbsp;<code>U</code>&nbsp;sau chiar&nbsp;<code>U</code>.</p>
                  <p class="indented">Fie&nbsp;<code>G=(X, U)</code>&nbsp;un graf neorientat. Un graf parțial al grafului&nbsp;<code>G</code>&nbsp;se obține păstr&acirc;nd v&acirc;rfurile şi<br />elimin&acirc;nd eventual nişte muchii (se pot elimina şi toate muchiile sau chiar nici una).</p>
                  <p><strong>Definiție.</strong>&nbsp;Fie&nbsp;<code>G=(X, U)</code>&nbsp;un graf orientat. Se numeşte&nbsp;<strong>subgraf</strong>&nbsp;al grafului&nbsp;<code>G</code>&nbsp;graful neorientat&nbsp;<code>G1=(X1,U1)</code>&nbsp;unde&nbsp;<code>X1 &sube; X</code>&nbsp;iar&nbsp;<code>U1</code>&nbsp;conține toate arcele din&nbsp;<code>U</code>&nbsp;care au extremitățile &icirc;n&nbsp;<code>X1</code>.</p>
                  <p>Din definiție rezultă:</p>
                  <p class="indented">Fie&nbsp;<code>G=(X,U)</code>&nbsp;un graf orientat. Un subgraf al grafului&nbsp;<code>G</code>, se obține şterg&acirc;nd eventual anumite<br />v&acirc;rfuri şi odată cu acestea şi muchiile care le admit ca extremitate (nu se pot şterge toate v&acirc;rfurile deoarece s-ar obține un graf cu mulțimea v&acirc;rfurilor vidă).</p>
                  <p><strong>Definiție.</strong>&nbsp;Fie&nbsp;<code>G=(X, U)</code>&nbsp;un graf neorientat. Se numeşte&nbsp;<strong>graf complementar</strong>&nbsp;al grafului&nbsp;<code>G</code>, graful neorientat&nbsp;<code>G1=(X, U1)</code>, cu proprietatea că două v&acirc;rfuri&nbsp;<code>x</code>&nbsp;și&nbsp;<code>y</code>&nbsp;sunt adiacente &icirc;n&nbsp;<code>G1</code>&nbsp;dacă și numai dacă nu sunt adiacente &icirc;n&nbsp;<code>G</code>.</p>
                  <p><strong>Exemplu:</strong></p>
                  <table class="table">
		                  <tbody>
                        <tr>
			                    <td class="col-md-3">Graful inițial </td>
			                    <td class="col-md-3">Graf parțial </td>
			                    <td class="col-md-3">Subgraf </td>
			                    <td class="col-md-3">Graf complementar </td>
		                    </tr>
		                    <tr>
			                    <td> <img alt="" src="graf-neorientat-2.png" style="margin:0px 0px 0px 0px;"> </td>
			                    <td> <img alt="" src="graf-neorientat-2-graf-partial.png" style="margin:0px 0px 0px 0px;"> </td>
			                    <td> <img alt="" src="graf-neorientat-2-subgraf.png" style="margin:0px 0px 0px 0px;"> </td>
			                    <td> <img alt="" src="graf-neorientat-2-complementar.png" style="margin:0px 0px 0px 0px;"> </td>
		                     </tr>
		                     <tr>
			                    <td> </td>
			                    <td class="small">S-au eliminat muchiile <code>[1,2]</code>, <code>[3,1]</code> </td>
			                    <td class="small">S-a eliminat vârfurile <code>3 5</code> și toate muchiile incidente cu ele. </td>
			                    <td class="small">O muchie <code>[x,y]</code> apare în graful complementar dacă și numai dacă nu apare în graful inițial. </td>
		                     </tr>
                      </tbody>

                  </table>
                  <p><strong>Observații.</strong>&nbsp;Un graf neorientat oarecare poate avea mai multe grafuri parțiale și subgrafuri, dar un unic graf complementar. Mai precis:</p>
                  <p><strong>Teoremă:</strong>&nbsp;Fie&nbsp;<code>G</code>&nbsp;un graf neorientat cu&nbsp;<code>n</code>&nbsp;v&acirc;rfuri și&nbsp;<code>m</code>&nbsp;muchii. Atunci:</p>
                  <p class="indented">graful&nbsp;<code>G</code>&nbsp;admite&nbsp;<span id="MathJax-Element-4-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/msup&gt;&lt;/math&gt;"><span id="MathJax-Span-159" class="math"><span id="MathJax-Span-160" class="mrow"><span id="MathJax-Span-161" class="msubsup"><span id="MathJax-Span-162" class="mn">2</span><span id="MathJax-Span-163" class="mi">m</span></span></span></span><span class="MJX_Assistive_MathML">2m</span></span>&nbsp;grafuri parțiale;</p>
                  <p class="indented">graful&nbsp;<code>G</code>&nbsp;admite&nbsp;<span id="MathJax-Element-5-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;&amp;#x2013;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-164" class="math"><span id="MathJax-Span-165" class="mrow"><span id="MathJax-Span-166" class="msubsup"><span id="MathJax-Span-167" class="mn">2</span><span id="MathJax-Span-168" class="mi">n</span></span><span id="MathJax-Span-169" class="mo">&ndash;</span><span id="MathJax-Span-170" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">2n&ndash;1</span></span>&nbsp;subgrafuri;</p>
                  <p class="indented">graful&nbsp;<code>G</code>&nbsp;admite un unic graf complementar.</p>
                  <p>Justificare:</p>
                  <p>Să ne amintim că o mulțime cu&nbsp;<code>a</code>&nbsp;elemente are&nbsp;<span id="MathJax-Element-6-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/msup&gt;&lt;/math&gt;"><span id="MathJax-Span-171" class="math"><span id="MathJax-Span-172" class="mrow"><span id="MathJax-Span-173" class="msubsup"><span id="MathJax-Span-174" class="mn">2</span><span id="MathJax-Span-175" class="mi">a</span></span></span></span><span class="MJX_Assistive_MathML">2a</span></span>&nbsp;submulțimi, inclusiv mulțimea vidă și mulțimea inițială. Atunci:</p>
                  <p class="indented">orice submulțime a mulțimii muchiilor induce un graf parțial. Sunt&nbsp;<code>m</code>&nbsp;muchii, deci&nbsp;<span id="MathJax-Element-7-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/msup&gt;&lt;/math&gt;"><span id="MathJax-Span-176" class="math"><span id="MathJax-Span-177" class="mrow"><span id="MathJax-Span-178" class="msubsup"><span id="MathJax-Span-179" class="mn">2</span><span id="MathJax-Span-180" class="mi">m</span></span></span></span><span class="MJX_Assistive_MathML">2m</span></span>&nbsp;submulțimi, deci&nbsp;<span id="MathJax-Element-8-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/msup&gt;&lt;/math&gt;"><span id="MathJax-Span-181" class="math"><span id="MathJax-Span-182" class="mrow"><span id="MathJax-Span-183" class="msubsup"><span id="MathJax-Span-184" class="mn">2</span><span id="MathJax-Span-185" class="mi">m</span></span></span></span><span class="MJX_Assistive_MathML">2m</span></span>&nbsp;grafuri parțiale.</p>
                  <p class="indented">orice submulțime a mulțimii v&acirc;rfuri induce un subgraf, mai puțin mulțimea vidă &ndash; un graf nu poate avea&nbsp;<code>0</code>&nbsp;v&acirc;rfuri. Similar ca mai sus, sunt&nbsp;<span id="MathJax-Element-9-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;&amp;#x2013;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-186" class="math"><span id="MathJax-Span-187" class="mrow"><span id="MathJax-Span-188" class="msubsup"><span id="MathJax-Span-189" class="mn">2</span><span id="MathJax-Span-190" class="mi">n</span></span><span id="MathJax-Span-191" class="mo">&ndash;</span><span id="MathJax-Span-192" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">2n&ndash;1</span></span>&nbsp;subgrafuri.</p>
                  <p class="indented">graful complementar este unic determinat, deoarece complementara unei submulțimi față de o mulțime dată este unic determinată.</p>
                <h2>Graf nul. Graf complet. Graf regulat. Graf bipartit</h2>
                  <p><strong>Definiție:</strong>&nbsp;Un graf neorientat se numește&nbsp;<strong>graf nul</strong>&nbsp;dacă mulțimea muchiilor este vidă.</p>
                  <p>&Icirc;ntr-un graf nul toate v&acirc;rfurile sunt izolate.</p>
                  <p><strong>Definiție.</strong>&nbsp;Fie&nbsp;<code>G=(X, U)</code>&nbsp;un graf neorientat. Graful&nbsp;<code>G</code>&nbsp;se numește&nbsp;<strong>graf complet</strong>&nbsp;dacă oricare două v&acirc;rfuri<br />distincte ale sale sunt adiacente. Un graf complet cu&nbsp;<code>n</code>&nbsp;v&acirc;rfuri se notează&nbsp;<code>K</code><sub><code>n</code></sub>.</p>
                  <p><strong>Exemplu:</strong>&nbsp;Graful următor este graful&nbsp;<code>K</code><sub><code>5</code></sub>.</p>
                  <img src="graf-neorientat-complet.png">
                  <p>&Icirc;ntr-un graf complet cu&nbsp;<code>n</code>&nbsp;v&acirc;rfuri sunt&nbsp;<span id="MathJax-Element-10-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msubsup&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msubsup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mfrac&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;#x2217;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-193" class="math"><span id="MathJax-Span-194" class="mrow"><span id="MathJax-Span-195" class="msubsup"><span id="MathJax-Span-196" class="mi">C</span><span id="MathJax-Span-197" class="mn">2</span><span id="MathJax-Span-198" class="mi">n</span></span><span id="MathJax-Span-199" class="mo">=</span><span id="MathJax-Span-200" class="texatom"><span id="MathJax-Span-201" class="mrow"><span id="MathJax-Span-202" class="mfrac"><span id="MathJax-Span-203" class="texatom"><span id="MathJax-Span-204" class="mrow"><span id="MathJax-Span-205" class="mi">n</span><span id="MathJax-Span-206" class="mo">&lowast;</span><span id="MathJax-Span-207" class="mo">(</span><span id="MathJax-Span-208" class="mi">n</span><span id="MathJax-Span-209" class="mo">&minus;</span><span id="MathJax-Span-210" class="mn">1</span><span id="MathJax-Span-211" class="mo">)</span></span></span><span id="MathJax-Span-212" class="mn">2</span></span></span></span></span></span><span class="MJX_Assistive_MathML">Cn2=n&lowast;(n&minus;1)2</span></span>&nbsp;muchii și fiecare v&acirc;rf are gradul&nbsp;<code>n-1</code>.</p>
                  <p><strong>Propoziție:</strong>&nbsp;Sunt&nbsp;<span id="MathJax-Element-11-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mfrac&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;#x2217;&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/math&gt;"><span id="MathJax-Span-213" class="math"><span id="MathJax-Span-214" class="mrow"><span id="MathJax-Span-215" class="msubsup"><span id="MathJax-Span-216" class="mn">2</span><span id="MathJax-Span-217" class="texatom"><span id="MathJax-Span-218" class="mrow"><span id="MathJax-Span-219" class="mfrac"><span id="MathJax-Span-220" class="texatom"><span id="MathJax-Span-221" class="mrow"><span id="MathJax-Span-222" class="mi">n</span><span id="MathJax-Span-223" class="mo">&lowast;</span><span id="MathJax-Span-224" class="mo">(</span><span id="MathJax-Span-225" class="mi">n</span><span id="MathJax-Span-226" class="mo">&minus;</span><span id="MathJax-Span-227" class="mn">1</span><span id="MathJax-Span-228" class="mo">)</span></span></span><span id="MathJax-Span-229" class="mn">2</span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">2n&lowast;(n&minus;1)2</span></span>&nbsp;grafuri neorientate distincte cu&nbsp;<code>n</code>&nbsp;v&acirc;rfuri.</p>
                  <p><strong>Definiție:</strong>&nbsp;Un graf &icirc;n care toate nodurile au acelaşi grad se numește&nbsp;<strong>graf regulat</strong>.</p>
                  <p><strong>Exemplu:</strong>&nbsp;Graful de mai jos este regulat.</p>
                  <img src="graf-regulat.png">
                  <p><strong>Definiţie:</strong>&nbsp;Un graf&nbsp;<code>G=(X, U)</code>&nbsp;se numește&nbsp;<strong>graf bipartit</strong>&nbsp;dacă există două mulţimi nevide&nbsp;<code>A</code>&nbsp;și&nbsp;<code>B</code>&nbsp;astfel &icirc;nc&acirc;t&nbsp;<code>X=A &cup; B</code>,&nbsp;<code>A &cap; B = &empty;</code>&nbsp;şi orice muchie&nbsp;<code>u</code>&nbsp;a lui&nbsp;<code>G</code>&nbsp;are o extremitate &icirc;n&nbsp;<code>A</code>&nbsp;iar cealaltă &icirc;n&nbsp;<code>B</code>. Mulţimile&nbsp;<code>A</code>&nbsp;şi&nbsp;<code>B</code>&nbsp;formează o partiţie a lui&nbsp;<code>X</code>.</p>
                  <p><strong>Exemplu:</strong>&nbsp;Graful următor este bipartit.&nbsp;<code>A={1,2,5,7}</code>&nbsp;și&nbsp;<code>B={3,4,6}</code>.</p>
                  <img src="graf-bipartit.png">
                  <p><strong>Definiție:</strong>&nbsp;Un graf bipartit&nbsp;<code>G=(X,U)</code>&nbsp;se numește&nbsp;<strong>bipartit complet</strong>&nbsp;dacă pentru oricare două v&acirc;rfuri&nbsp;<span id="MathJax-Element-12-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;&amp;#x2208;&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-230" class="math"><span id="MathJax-Span-231" class="mrow"><span id="MathJax-Span-232" class="mi">x</span><span id="MathJax-Span-233" class="mo">&isin;</span><span id="MathJax-Span-234" class="mi">A</span></span></span><span class="MJX_Assistive_MathML">x&isin;A</span></span>&nbsp;și&nbsp;<span id="MathJax-Element-13-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;&amp;#x2208;&lt;/mo&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-235" class="math"><span id="MathJax-Span-236" class="mrow"><span id="MathJax-Span-237" class="mi">y</span><span id="MathJax-Span-238" class="mo">&isin;</span><span id="MathJax-Span-239" class="mi">B</span></span></span><span class="MJX_Assistive_MathML">y&isin;B</span></span>, există &icirc;n graf muchia&nbsp;<code>[x,y]</code>; adică&nbsp;<span id="MathJax-Element-14-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;mo&gt;&amp;#x2208;&lt;/mo&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-240" class="math"><span id="MathJax-Span-241" class="mrow"><span id="MathJax-Span-242" class="mo">[</span><span id="MathJax-Span-243" class="mi">x</span><span id="MathJax-Span-244" class="mo">,</span><span id="MathJax-Span-245" class="mi">y</span><span id="MathJax-Span-246" class="mo">]</span><span id="MathJax-Span-247" class="mo">&isin;</span><span id="MathJax-Span-248" class="mi">U</span></span></span><span class="MJX_Assistive_MathML">[x,y]&isin;U</span></span>.</p>
                  <p><strong>Exemplu:</strong>&nbsp;Graful următor este bipartit complet.</p>
                  <img src="graf-bipartit-complet.png">
              <h1>Conexitate</h1>
                <h2>Lanț, ciclu</h2>
                  <p><strong>Definiție:</strong>&nbsp;Se numește&nbsp;<strong>lanț</strong>&nbsp;o succesiune de v&acirc;rfuri&nbsp;<span id="MathJax-Element-15-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mo&gt;&amp;#x22EF;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-249" class="math"><span id="MathJax-Span-250" class="mrow"><span id="MathJax-Span-251" class="mi">L</span><span id="MathJax-Span-252" class="mo">=</span><span id="MathJax-Span-253" class="mrow"><span id="MathJax-Span-254" class="mo">[</span><span id="MathJax-Span-255" class="mrow"><span id="MathJax-Span-256" class="msubsup"><span id="MathJax-Span-257" class="mi">x</span><span id="MathJax-Span-258" class="mn">1</span></span><span id="MathJax-Span-259" class="mo">,</span><span id="MathJax-Span-260" class="msubsup"><span id="MathJax-Span-261" class="mi">x</span><span id="MathJax-Span-262" class="mn">2</span></span><span id="MathJax-Span-263" class="mo">,</span><span id="MathJax-Span-264" class="mo">⋯</span><span id="MathJax-Span-265" class="msubsup"><span id="MathJax-Span-266" class="mi">x</span><span id="MathJax-Span-267" class="mi">k</span></span></span><span id="MathJax-Span-268" class="mo">]</span></span></span></span><span class="MJX_Assistive_MathML">L=[x1,x2,⋯xk]</span></span>&nbsp;cu proprietatea că oricare două v&acirc;rfuri consecutive sunt adiacente.</p>
                  <p>V&acirc;rfurile&nbsp;<code>x</code><sub><code>1</code></sub>&nbsp;şi&nbsp;<code>x</code><sub><code>k</code></sub>&nbsp;se numesc extremitățile lanțului. Numărul&nbsp;<code>k-1</code>&nbsp;se numește lungimea lanțului și este numărul de muchii din care este format.</p>
                  <p>Lanțul care conține numai v&acirc;rfuri distincte, două c&acirc;te două, este lanț&nbsp;<strong>elementar</strong>.</p>
                  <p>Lanțul care conține numai muchii distincte este&nbsp;<strong>lanț simplu</strong>. Dacă muchiile unui lanț nu sunt distincte se numește&nbsp;<strong>lanț compus</strong>.</p>
                  <p><strong>Definiție:</strong>&nbsp;Se numește&nbsp;<strong>ciclu</strong>&nbsp;un lanț simplu &icirc;n care primul v&acirc;rf este identic cu ultimul. Dacă toate v&acirc;rfurile sunt distincte, mai puțin primul și ultimul, se numește&nbsp;<strong>ciclu elementar</strong>.</p>
                  <p><strong>Lungimea unui ciclu</strong>&nbsp;este egală cu numărul de muchii din ciclu. Lungimea minimă a unui ciclu este&nbsp;<code>3</code>.</p>
                  <p>Un ciclu se numește&nbsp;<strong>par</strong>&nbsp;dacă lungimea sa este pară, respectiv&nbsp;<strong>impar</strong>&nbsp;&icirc;n caz contrar.</p>
                  <p>Un graf neorientat care nu conține niciun ciclu se numește&nbsp;<strong>aciclic</strong>.</p>
                  <p><strong>Exemple:</strong>&nbsp;&Icirc;n graful de mai jos:</p>
                  <img src="graf-neorientat-3 (1).png">
                  <p><code>[2,4,1,3,5,7]</code> este un lanț elementar</p>
                  <p><code>[3,5,7,6,5,1]</code> este un lanț neelementar, dar simplu</p>
                  <p><code>[2,3,5,7,6,5,3,1]</code> este un lanț compus</p>
                  <p><code>[1,5,3,2,4,1]</code> este un ciclu elementar</p>
                  <p><code>[1,3,5,7,6,5,1]</code> este un ciclu neelementar</p>
                <h2>Graf conex. Componente conexe</h2>
                  <p><strong>Definiție:</strong>&nbsp;Un graf neorientat se numește&nbsp;<strong>graf conex</strong>&nbsp;dacă pentru oricare două v&acirc;rfuri&nbsp;<code>x</code>&nbsp;și&nbsp;<code>y</code>&nbsp;diferite ale sale, există cel puțin un lanț care le leagă, adică&nbsp;<code>x</code>&nbsp;este extremitatea inițială și&nbsp;<code>y</code>&nbsp;este extremitatea finală.</p>
                  <p>Un graf cu un singur nod este, prin definiție, conex.</p>
                  <p><strong>Definiție:</strong>&nbsp;Se numește&nbsp;<strong>componentă conexă</strong>&nbsp;a unui graf&nbsp;<code>G=(X,U)</code>&nbsp;un subgraf&nbsp;<code>H=(Y, V)</code>, conex, al lui&nbsp;<code>G</code><br />care are proprietatea că nu există nici un lanț &icirc;n G care să lege un v&acirc;rf din&nbsp;<code>Y</code>&nbsp;cu un v&acirc;rf din&nbsp;<code>X &ndash; Y</code>.</p>
                  <p>Subgraful&nbsp;<code>H</code>&nbsp;este conex și maximal cu această proprietate (dacă s-ar mai adăuga un v&acirc;rf nu ar mai fi conex.)</p>
                  <p>Un graf este conex dacă admite o singură componentă conexă.</p>
                  <p><strong>Exemple:</strong></p>
                  <p>Graful următor este conex:</p>
                  <img src="graf-neorientat-3 (2).png">
                  <p>Graful următor nu este conex și are 4 componente conexe.</p>
                  <img src="graf-neorientat-0.png">
                  <p><strong>Definiție:</strong>&nbsp;Un graf este&nbsp;<strong>biconex</strong>&nbsp;dacă este conex şi pentru orice v&acirc;rf eliminat subgraful generat &icirc;şi păstrează proprietatea de conexitate.</p>
                <h2>Arbore. Pădure</h2>
                  <p><strong>Definiție:</strong>&nbsp;Se numește&nbsp;<strong>arbore</strong>&nbsp;un graf conex și aciclic.</p>
                  <p><strong>Exemplu:</strong>&nbsp;Graful următor este arbore:</p>
                  <img src="graf-arbore.png">
                  <p><strong>Observații:</strong></p>
                  <p class="indented">Un arbore cu&nbsp;<code>n</code>&nbsp;v&acirc;rfuri are&nbsp;<code>n-1</code>&nbsp;muchii.</p>
                  <p class="indented">Un arbore este un graf conex și minimal cu această proprietate; dacă s-ar mai elimina o muchie, graful nu ar mai fi conex.</p>
                  <p class="indented">Un arbore este un graf aciclic și maximal cu această proprietate; dacă s-ar mai adăuga o muchie, s-ar obține un ciclu.</p>
                  <p>Un graf parțial care este arbore se numește&nbsp;<strong>arbore parțial</strong>.</p>
                  <p>Un graf care nu conține cicluri se mai numește&nbsp;<strong>pădure</strong>. &Icirc;ntr-o pădure fiecare componentă conexă este arbore.</p>
              <h1>Graf hamiltonian. Graf eulerian</h1>
                <p><strong>Definiție:</strong>&nbsp;Se numește&nbsp;<strong>graf hamiltonian</strong>&nbsp;un graf care conține un ciclu hamiltonian. Se numește&nbsp;<strong>ciclu hamiltonian</strong>&nbsp;un ciclu elementar care conține toate v&acirc;rfurile grafului.</p>
                <p>&Icirc;ntr-un graf neorientat, se numește&nbsp;<strong>lanț hamiltonian</strong>&nbsp;un lanț elementar care conține toate v&acirc;rfurile grafului.</p>
                <p>&Icirc;ntr-un graf neorientat, se numește&nbsp;<strong>ciclu hamiltonian</strong>&nbsp;un ciclu elementar care conține toate v&acirc;rfurile grafului.</p>
                <p>Un graf neorientat se numește&nbsp;<strong>graf hamiltonian</strong>&nbsp;dacă conține un ciclu hamiltonian.</p>
                <p><strong>Exemplu:</strong>&nbsp;Graful următor este hamiltonian. Un ciclu hamiltonian este:&nbsp;<span id="MathJax-Element-21-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-350" class="math"><span id="MathJax-Span-351" class="mrow"><span id="MathJax-Span-352" class="mo">[</span><span id="MathJax-Span-353" class="mn">1</span><span id="MathJax-Span-354" class="mo">,</span><span id="MathJax-Span-355" class="mn">4</span><span id="MathJax-Span-356" class="mo">,</span><span id="MathJax-Span-357" class="mn">2</span><span id="MathJax-Span-358" class="mo">,</span><span id="MathJax-Span-359" class="mn">3</span><span id="MathJax-Span-360" class="mo">,</span><span id="MathJax-Span-361" class="mn">7</span><span id="MathJax-Span-362" class="mo">,</span><span id="MathJax-Span-363" class="mn">6</span><span id="MathJax-Span-364" class="mo">,</span><span id="MathJax-Span-365" class="mn">5</span><span id="MathJax-Span-366" class="mo">,</span><span id="MathJax-Span-367" class="mn">1</span><span id="MathJax-Span-368" class="mo">]</span></span></span></span></p>
                <img src="graf-hamilton-euler.png">
                <p><strong>Teoremă:</strong>&nbsp;Un&nbsp;<code>G</code>&nbsp;un graf neorientat. Dacă are&nbsp;<code>n&ge;3</code>&nbsp;v&acirc;rfuri şi gradul oricărui v&acirc;rf verifică inegalitatea&nbsp;<code>d(x)&ge;n/2</code>&nbsp;atunci&nbsp;<code>G</code>&nbsp;este hamiltonian.</p>
                <p><strong>Definiție:</strong>&nbsp;Se numește&nbsp;<strong>graf eulerian</strong>&nbsp;un graf care conține un ciclu eulerian. Se numește&nbsp;<strong>ciclu eulerian</strong>&nbsp;un ciclu care conține toate muchiile grafului.</p>
                <p>&Icirc;ntr-un graf neorientat, se numește&nbsp;<strong>lanț eulerian</strong>&nbsp;un lanț simplu &icirc;n care apare fiecare muchie (fiind lanț simplu, fiecare muchie apare o singură dată).</p>
                <p>&Icirc;ntr-un graf neorientat, se numește&nbsp;<strong>ciclu eulerian</strong>&nbsp;un ciclu &icirc;n care apare fiecare muchie.</p>
                <p>Un graf neorientat se numește&nbsp;<strong>graf eulerian</strong>&nbsp;dacă conține un ciclu eulerian.</p>
                <p><strong>Exemplu:</strong>&nbsp;Graful următor este eulerian. Un ciclu eulerian este:&nbsp;<span id="MathJax-Element-22-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;7&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-369" class="math"><span id="MathJax-Span-370" class="mrow"><span id="MathJax-Span-371" class="mo">[</span><span id="MathJax-Span-372" class="mn">1</span><span id="MathJax-Span-373" class="mo">,</span><span id="MathJax-Span-374" class="mn">4</span><span id="MathJax-Span-375" class="mo">,</span><span id="MathJax-Span-376" class="mn">2</span><span id="MathJax-Span-377" class="mo">,</span><span id="MathJax-Span-378" class="mn">1</span><span id="MathJax-Span-379" class="mo">,</span><span id="MathJax-Span-380" class="mn">3</span><span id="MathJax-Span-381" class="mo">,</span><span id="MathJax-Span-382" class="mn">2</span><span id="MathJax-Span-383" class="mo">,</span><span id="MathJax-Span-384" class="mn">7</span><span id="MathJax-Span-385" class="mo">,</span><span id="MathJax-Span-386" class="mn">3</span><span id="MathJax-Span-387" class="mo">,</span><span id="MathJax-Span-388" class="mn">5</span><span id="MathJax-Span-389" class="mo">,</span><span id="MathJax-Span-390" class="mn">7</span><span id="MathJax-Span-391" class="mo">,</span><span id="MathJax-Span-392" class="mn">6</span><span id="MathJax-Span-393" class="mo">,</span><span id="MathJax-Span-394" class="mn">5</span><span id="MathJax-Span-395" class="mo">,</span><span id="MathJax-Span-396" class="mn">1</span><span id="MathJax-Span-397" class="mo">]</span></span></span></span></p>
                <img src="graf-hamilton-euler (1).png">
                <p><strong>Teoremă:</strong>&nbsp;Un graf&nbsp;<code>G = (X,U)</code>, fără v&acirc;rfuri izolate, este eulerian dacă şi numai dacă este conex şi<br />gradele tuturor v&acirc;rfurilor sale sunt numere pare.</p>
            </div>


            <div class="textbox" id="PGN">
               <h1>Parcurgerea grafurilor neorientate</h1>
                <p>Prin parcurgerea unui graf neorientat se &icirc;nţelege examinarea &icirc;n mod sistematic a v&acirc;rfurilor, plec&acirc;nd dintr-un v&acirc;rf dat&nbsp;<code>start</code>, astfel &icirc;nc&acirc;t fiecare v&acirc;rf accesibil din&nbsp;<code>start</code>&nbsp;pe muchii incidente două c&acirc;te două să fie vizitat o singură dată. Trecerea de la un v&acirc;rf&nbsp;<code>x</code>&nbsp;la altul se face prin examinarea, &icirc;ntr-o anumită ordine a vecinilor săi.</p>
                <p>Parcurgerile grafurilor sunt frecvent utilizate &icirc;n rezolvarea multor probleme. Animația de mai jos, (preluată de&nbsp;<a href="https://brilliant.org/wiki/depth-first-search-dfs/">aici</a>) prezintă modul &icirc;n care se parcurge un labirint folosind mecanisul parcurgerii &icirc;n ad&acirc;ncime.</p>
                <img src="54429cab5dc05daafae44df6aae405409f240684.gif" style="margin:0px 0px 0px 0px;height:50%; width:auto;">
               <h1>Parcurgerea în adâncime</h1>
                <p>Parcurgerea în adâncime reprezintă explorarea “naturală” a unui graf neorientat. Este foarte asemănătoare cu modul în care un turist vizitează un oraș în care sunt obiective turistice (vârfurile grafului) și căi de acces între obiective (muchiile). Vizitarea orașului va avea loc din aproape în aproape: se pleacă de la un obiectiv de pornire, se continuă cu un obiectiv învecinat cu acesta, apoi unul învecinat cu al doilea, etc.</p>
                <p>Parcurgerea în adâncime se face astfel:</p>
                <p class="indented">Se &icirc;ncepe cu un v&acirc;rf inițial&nbsp;<code>x</code>, care este &icirc;n acest moment&nbsp;<strong>v&acirc;rf curent</strong>.</p>
                <p class="indented">V&acirc;rful&nbsp;<code>x</code>&nbsp;se vizitează. Se determină primul său vecin nevizitat&nbsp;<code>y</code>&nbsp;al lui&nbsp;<code>x</code>, care devine v&acirc;rf curent.</p>
                <p class="indented">Apoi se vizitează primul vecin nevizitat al lui&nbsp;<code>y</code>, şi aşa mai departe, merg&acirc;nd &icirc;n ad&acirc;ncime, p&acirc;nă c&acirc;nd ajungem la un v&acirc;rf care nu mai are vecini nevizitați. C&acirc;nd ajungem &icirc;ntr-un astfel de v&acirc;rf, ne &icirc;ntoarcem la &ldquo;părintele&rdquo; acestuia &ndash; v&acirc;rful din care am ajuns &icirc;n acesta.</p>
                <p class="indented">Dacă acest v&acirc;rf mai are vecini nevizitați, alegem următorul vecin nevizitat al său și continuam parcurgerea &icirc;n același mod.</p>
                <p class="indented">Dacă nici acest v&acirc;rf nu mai are vecini nevizitați, revenim &icirc;n v&acirc;rful său părinte și continuăm &icirc;n același mod, p&acirc;nă c&acirc;nd toate v&acirc;rfurile accesibile din v&acirc;rful de start sunt vizitate.</p>
                <h2>Observație</h2>
                  <p>Dacă graful nu este conex, nu ser vor vizita toate vârfurile.</p>
                <h2>Exemplu</h2>
                  <img src="dfs-animatie-x1.gif">
                  <p>Parcurgerea din nodul&nbsp;<code>5</code>:&nbsp;<code>5 2 1 4 6 3 7 8 9</code></p>
                  <p>Alte exemple de parcurgere pe acest graf:</p>
                  <img src="graf-parcurgere-1.png">
                  <p class="indented">Parcurgerea din nodul&nbsp;<code>1</code>:&nbsp;<code>1 2 3 5 4 6 7 8 9</code></p>
                  <p class="indented">Parcurgerea din nodul&nbsp;<code>2</code>:&nbsp;<code>2 1 4 5 7 8 9 6 3</code></p>
                  <p class="indented">Parcurgerea din nodul&nbsp;<code>9</code>:&nbsp;<code>9 7 5 2 1 4 6 3 8</code></p>
                  <p>Pentru implementarea algoritmului se foloseşte un vector caracteristic pentru memorarea faptului că un anume v&acirc;rf a fost sau nu vizitat, la un anumit moment al parcurgerii:</p>
                  <p class="indented"><code>v[i] = 0</code>, v&acirc;rful&nbsp;<code>i</code>&nbsp;nu a fost (&icirc;ncă) vizitat</p>
                  <p class="indented"><code>v[i] = 1</code>, v&acirc;rful&nbsp;<code>i</code>&nbsp;a fost vizitat</p>
                  <p>Pentru a determina ordinea &icirc;n care se parcurg nodurile care pot fi vizitate, se folosește o stivă:</p>
                  <p class="indented">se analizează mereu nodurile adiacent cu nodul din v&acirc;rful stivei</p>
                  <p class="indented">dacă pentru nodul din v&acirc;rful stivei găsim un vecin nevizitat, adăugăm nodul vecin pe stivă</p>
                  <p class="indented">dacă pentru nodul din v&acirc;rful stivei nu mai găsim niciun vecin nevizitat, &icirc;l eliminăm de pe stivă</p>
                  <p>Pentru implementare se poate folosi ca stivă memoria&nbsp;<span class="caps">STACK</span>, prin intermediul recursivității.</p>
                <h2>Implementare C++</h2>
                  <p>Presupunem că graful are n noduri și este prezentat prin matricea de adiacență a. Starea unui vârf (vizitat sau nu) este memorată în vectorul caracteristic v. Toate aceste variabile sunt globale.</p>
                  <pre style="font-size:20px;" class="code_c cm-s-default" data-lang="text/x-csrc" contenteditable="true" editable="true">
                <span class="cm-keyword">void</span> <span class="cm-variable">dfs</span>(<span class="cm-keyword">int</span> <span class="cm-variable">k</span>){
                  <span class="cm-variable">v</span>[<span class="cm-variable">k</span>]<span class="cm-operator">=</span><span class="cm-number">1</span>; <span class="cm-comment">//vizitam varful curent x</span>
                  <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">i</span><span class="cm-operator">=</span><span class="cm-number">1</span>;<span class="cm-variable">i</span><span class="cm-operator">&lt;=</span><span class="cm-variable">n</span>;<span class="cm-variable">i</span><span class="cm-operator">++</span>) <span class="cm-comment">// determinam vecinii nevizitati ai lui x</span>
                    <span class="cm-keyword">if</span>(<span class="cm-variable">a</span>[<span class="cm-variable">k</span>][<span class="cm-variable">i</span>]<span class="cm-operator">==</span><span class="cm-number">1</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">v</span>[<span class="cm-variable">i</span>]<span class="cm-operator">==</span><span class="cm-number">0</span>){
                      <span class="cm-variable">dfs</span>(<span class="cm-variable">i</span>); <span class="cm-comment">// continuam parcurgerea cu vecinul curent i</span>
                    }
                }
                  </pre>
                <h2>Parcurgerea în lățime</h2>
                  <p>Se parcurge vârful de start, apoi vecinii acestuia, apoi vecinii nevizitați ai acestora, etc, până când sunt vizitate toate vârfurile accesibile. Practic, pentru a stabili ordinea de vizitare se folosește o coadă, iar pentru a stabili dacă un vârf a fost sau nu vizitat se foloseşte un vector caracteristic.</p>
                  <p>Algoritmul este:</p>
                  <p class="indented">adaugăm în coadă vârful inițial și îl vizităm</p>
                  <p class="indented">cât timp coada este nevidă
                    <p class="indented">extragem un element din coadă</p>
                    <p class="indented">determinăm vecinii nevizitați ai vârfului extras, îi vizităm și îi adăugăm în coadă</p>
                    <p class="indented">eliminăm elementul din coadă</p>
                  </p>
                <h2>Observație</h2>
                  <p>Dacă graful nu este conex, în urma parcurgerii nu se vor vizita toate vârfurile.</p>
                <h2>Exemplu</h2>
                  <img src="bfs-animatie-1x.gif">
                  <pre style="font-size:20px;" class="code_c cm-s-default" contenteditable="true" data-lang="text/x-csrc">V&acirc;rfurile grafului au fost parcurse &icirc;n ordinea:&nbsp;<code>5 2 4 7 1 3 6 8 9</code>.</pre>
                <h2>Implementare C++</h2>
                  <p>Funcţia de mai jos presupune că un graf cu&nbsp;<code>n</code>&nbsp;v&acirc;rfuri este memorat prin intermediul matricei de adiacenţă, vectorul&nbsp;<code>x[]</code>&nbsp;reprezintă coada, vectorul&nbsp;<code>v[]</code>, aceste variabile fiind declarate global. Funcţia returnează numărul de elemente care au fost vizitate.</p>
                  <pre style="font-size:20px;"class="code_c cm-s-default" data-lang="text/x-csrc" contenteditable="true" editable="true"><span class="cm-keyword">int</span> <span class="cm-variable">bfs</span>(<span class="cm-keyword">int</span> <span class="cm-variable">start</span>)
{
  <span class="cm-keyword">int</span> <span class="cm-variable">i</span>,<span class="cm-variable">k</span>,<span class="cm-variable">st</span>,<span class="cm-variable">dr</span>;
  <span class="cm-comment">//initializez coada</span>
  <span class="cm-variable">st</span><span class="cm-operator">=</span><span class="cm-variable">dr</span><span class="cm-operator">=</span><span class="cm-number">1</span>;
  <span class="cm-variable">x</span>[<span class="cm-number">1</span>]<span class="cm-operator">=</span><span class="cm-variable">start</span>;
  <span class="cm-variable">v</span>[<span class="cm-variable">start</span>]<span class="cm-operator">=</span><span class="cm-number">1</span>;<span class="cm-comment">//vizitez varful initial</span>
  <span class="cm-keyword">while</span>(<span class="cm-variable">st</span><span class="cm-operator">&lt;=</span><span class="cm-variable">dr</span>)<span class="cm-comment">//cat timp coada nu este vida</span>
  {
    <span class="cm-variable">k</span><span class="cm-operator">=</span><span class="cm-variable">x</span>[<span class="cm-variable">st</span>];<span class="cm-comment">//preiau un element din coada</span>
    <span class="cm-keyword">for</span>(<span class="cm-variable">i</span><span class="cm-operator">=</span><span class="cm-number">1</span>;<span class="cm-variable">i</span><span class="cm-operator">&lt;=</span><span class="cm-variable">n</span>;<span class="cm-variable">i</span><span class="cm-operator">++</span>)<span class="cm-comment">//parcurg varfurile</span>
      <span class="cm-keyword">if</span>(<span class="cm-variable">v</span>[<span class="cm-variable">i</span>]<span class="cm-operator">==</span><span class="cm-number">0</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">a</span>[<span class="cm-variable">k</span>][<span class="cm-variable">i</span>]<span class="cm-operator">==</span><span class="cm-number">1</span>)<span class="cm-comment">//daca i este vecin cu k si nu este vizitat</span>
      {
        <span class="cm-variable">v</span>[<span class="cm-variable">i</span>]<span class="cm-operator">=</span><span class="cm-number">1</span>;<span class="cm-comment">//il vizitez</span>
        <span class="cm-variable">x</span>[<span class="cm-operator">++</span><span class="cm-variable">dr</span>]<span class="cm-operator">=</span><span class="cm-variable">i</span>;<span class="cm-comment">//il adaug in coada</span>
      }
    <span class="cm-variable">st</span><span class="cm-operator">++</span>;<span class="cm-comment">//sterg din coada</span>
  }
  <span class="cm-keyword">return</span> <span class="cm-variable">dr</span>;<span class="cm-comment">//returnam numarul de varfuri vizitate</span>
}</pre>
              <h2>Aplicații ale parcurgerii grafurilor</h2>
                <p>Parcurgerea grafurilor neorientate poate fi folosită în rezolvarea unei game largi de probleme: verificarea conexității unui graf, determinarea componentelor conexe ale unui graf, determinarea unor lanțuri în graf, verificarea faptului că un graf este bipartit, etc.</p>
              <h2>Verificarea conexității</h2>
                <p><strong>Definiție:</strong>&nbsp;Un graf se numește&nbsp;<em>conex</em>&nbsp;dacă &icirc;ntre oricare două v&acirc;rfuri există cel puțin un lanț.</p>
                <p>Pentru a verifica dacă un graf este conex, putem folosi oricare metodă de parcurgere, astfel:</p>
                <p class="indented">stabilim un v&acirc;rf de start</p>
                <p class="indented">realizăm o parcurgere pornind din v&acirc;rful de start</p>
                <p class="indented">la final verificăm dacă au fost parcurse toate v&acirc;rfurile, folosind vectorul&nbsp;<code>v</code>&nbsp;de mai sus; &icirc;n caz afirmativ, graful este conex, altfel graful nu este conex.</p>
              <h2>Determinarea componentelor conexe</h2>
                <p><strong>Definiție:</strong>&nbsp;Se numește componentă conexă &icirc;ntr-un graf neorientat un subgraf conex și maximal cu această proprietate.</p>
                <p>Determinarea componentelor conexe se poate face folosind un algoritm de parcurgere. &Icirc;n vectorul&nbsp;<code>v</code>&nbsp;v&acirc;rfurile vizitate se vor marca cu valori&nbsp;<code>1</code>,&nbsp;<code>2</code>, etc. Fiecare valoare&nbsp;<code>v[i]</code>&nbsp;reprezintă componenta conexă din care face parte v&acirc;rful&nbsp;<code>i</code>.</p>
                <p class="indented"><code>nrc = 0</code></p>
                <p class="indented">parcurgem v&acirc;rfurile</p>
                <p class="indented">dacă v&acirc;rful curent nu este vizitat</p>
                <p class="indented">incrementăm&nbsp;<code>nrc</code>&nbsp;cu&nbsp;<code>1</code></p>
                <p class="indented">parcurgem graful pornind din v&acirc;rful curent și marcăm &icirc;n vectorul&nbsp;<code>v[]</code>&nbsp;v&acirc;rfurile parcurse cu&nbsp;<code>nrc</code></li></p>
                <p class="indented">la final,&nbsp;<code>nrc</code>&nbsp;reprezintă numărul de componente conexe, și toate v&acirc;rfurile din aceiași componentă sunt marcate &icirc;n&nbsp;<code>v[]</code>&nbsp;cu aceiași valoare.</p>
              <h2>Determinarea unor lanțuri</h2>
                <p>Pentru a determina un lanț cu extremitățile &icirc;n nodurile&nbsp;<code>x y</code>, vom realiza o parcurgere pornind de exemplu din&nbsp;<code>x</code>. Dacă se cere un lanț de lungime minimă, vom realiza neapărat o parcurgere &icirc;n lățime.</p>
                <p>Pentru determinarea lanțului vom construi și arborele de parcurgere.</p>
                <p>&Icirc;n timpul parcurgerii, c&acirc;nd avem nodul curent&nbsp;<code>k</code>&nbsp;și am stabilit că nodul&nbsp;<code>p</code>&nbsp;este adiacent cu&nbsp;<code>k</code>&nbsp;și nevizitat (deci urmează a fi parcurs), vom realiza și operația:&nbsp;<code>t[p] = k;</code>, unde&nbsp;<code>t</code>&nbsp;este vectorul de tați al arborelui de parcurgere.</p>
                <p>Lanțul propriu-zis se va reconstitui din vectorul de tați al arborelui. &Icirc;n secvența de mai jos considerăm că parcurgerea a &icirc;nceput din v&acirc;rful&nbsp;<code>x</code>. Nodurile sunt afișate de la&nbsp;<code>y</code>&nbsp;spre rădăcina&nbsp;<code>x</code>, deci ar putea fi necesar să fie afișate &icirc;n ordine inversă (de exemplu, să le memorăm &icirc;ntr-un tablou și să afișăm invers elementele tabloului).</p>
                <pre style="font-size:20px" contenteditable="true" editable="true">int p = y;
while(p != 0)
{
    cout &lt;&lt; p;
    p = t[p];
}
                </pre>
              <h2>Verificarea proprietății de graf bipartit</h2>
                <p>Un graf este bipartit dacă și numai dacă nu are cicluri de lungime impară. Pentru verificare, vom realiza o parcurgere &icirc;n ad&acirc;ncime pornind dintr-un v&acirc;rf oarecare, de exemplu&nbsp;<code>1</code>. Pentru a identifica existența unui ciclu de lungime impară, vom marca nodurile vizitate alternativ cu&nbsp;<code>1</code>&nbsp;sau&nbsp;<code>2</code>, astfel:</p>
                <p class="indented">marcăm nodul curent cu valoare&nbsp;<code>x</code></p>
                <p class="indented">identificăm vecinii nodului curent</p>
                <p class="indented">dacă nodul vecin nu a fost &icirc;ncă vizitat, &icirc;l marcăm cu cealaltă valoare (<code>3-x</code>) și continuăm parcurgerea cu el</p>
                <p class="indented">dacă nodul vecin a fost deja vizitat, acolo se &icirc;nchide un ciclu. Dacă la vizitare acest nod a fost marcat tot cu valoarea&nbsp;<code>x</code>, atunci acel ciclu are lungime impară, deci graful nu este bipartit.</p>
                <p>Dacă graful nu este conex, procedăm similar pentru fiecare componentă conexă.</p>
                <p>La final, dacă graful este bipartit, modul &icirc;n care am marcat nodurile ne dau și cele două submulțimi de noduri ale grafului bipartit. Mai precis, nodurile marcate cu&nbsp;<code>1</code>&nbsp;fac parte din prima submulțime, iar cele marcate cu&nbsp;<code>2</code>&nbsp;fac parte din a doua submulțime.</p>
             </div>


             <div class="textbox" id="TGO">
              <img src="avioane.jpg" style="width:75%; height:auto;">
              <h1>Definiții</h1>
                <p><strong>Definiție.</strong>&nbsp;Se numeşte&nbsp;<strong>graf orientat</strong>&nbsp;sau&nbsp;<strong>digraf</strong>&nbsp;o pereche ordonată de mulțimi notată&nbsp;<code>G=(V, U)</code>, unde:</p>
                <p class="indented"><code>V</code>&nbsp;este o mulțime finită şi nevidă ale cărei elemente se numesc&nbsp;<strong>noduri</strong>&nbsp;sau&nbsp;<strong>v&acirc;rfuri</strong>;</p>
                <p class="indented"><code>U</code>&nbsp;este o mulțime de perechi ordonate de elemente distincte din&nbsp;<code>V</code>&nbsp;ale cărei elemente se numesc&nbsp;<strong>arce</strong>.</p>
                <p><strong>Exemplu:</strong></p>
                <img src="graf-orientat.png">
                <p><code>V={1,2,3,4,5,6}</code><br /><code>U={(1,6),(2,1),(2,4),(3,2),(4,2),(5,4),(6,1),(6,4)}</code></p>
                <p>Observăm că arcele&nbsp;<code>(1,6)</code>&nbsp;și&nbsp;<code>(6,1)</code>&nbsp;sunt distincte.</p>
                <h2>Noțiuni</h2>
                  <p><strong>extremități ale unui arc:</strong>&nbsp;pentru arcul u=(x,y), se numesc&nbsp;<strong>extremități</strong>&nbsp;ale sale nodurile&nbsp;<code>x</code>&nbsp;şi&nbsp;<code>y</code>;</p>
                  <p class="indented"><code>x</code>&nbsp;se numeşte extremitate inițială;</p>
                  <p class="indented"><code>y</code>&nbsp;se numeşte extremitate finală;</p>
                  <p class="indented"><code>y</code>&nbsp;se numește&nbsp;<strong>succesor</strong>&nbsp;al lui&nbsp;<code>x</code>;</p>
                  <p class="indented"><code>x</code>&nbsp;se numește&nbsp;<strong>predecesor</strong>&nbsp;al lui&nbsp;<code>y</code>.</p>
                  <p><strong>v&acirc;rfuri adiacente:</strong>&nbsp;dacă &icirc;ntr-un graf există arcul&nbsp;<code>u=(x,y)</code>&nbsp;(sau&nbsp;<code>u=(y,x)</code>, sau am&acirc;ndouă), se spune despre nodurile&nbsp;<code>x</code>&nbsp;şi&nbsp;<code>y</code>&nbsp;că sunt adiacente;</p>
                  <p><strong>incidență:</strong></p>
                  <p class="indented">dacă&nbsp;<code>u1</code>&nbsp;şi&nbsp;<code>u2</code>&nbsp;sunt două arce ale aceluiaşi graf, se numesc incidente dacă au o extremitate comună. Exemplu:&nbsp;<code>u1=(x,y)</code>&nbsp;şi&nbsp;<code>u2=(y,z)</code>&nbsp;sunt incidente;</p>
                  <p class="indented">dacă&nbsp;<code>u1=(x,y)</code>&nbsp;este un arc &icirc;ntr-un graf, se spune despre el şi nodul&nbsp;<code>x</code>, sau nodul&nbsp;<code>y</code>, că sunt incidente.</p>
                <h2>Definiții alternative</h2>
                  <p><strong>Definiție.</strong>&nbsp;Se numeşte&nbsp;<strong>graf orientat</strong>&nbsp;o pereche ordonată de mulțimi notată&nbsp;<code>G=(V, U)</code>, unde:</p>
                  <p class="indented"><code>V</code>&nbsp;este o mulțime, finită şi nevidă, ale cărei elemente se numesc&nbsp;<strong>noduri</strong>&nbsp;sau&nbsp;<strong>v&acirc;rfuri</strong>;</p>
                  <p class="indented"><code>U</code>&nbsp;este o mulțime, de perechi ordonate de elemente din&nbsp;<code>V</code>, ale cărei elemente se numesc&nbsp;<strong>arce</strong>.</p>
                  <p>Această definiție diferă de prima definiție prin faptul ca acum nu se mai spune despre extremitățile unui arc<br />ca trebuie să fie distincte. &Icirc;n baza acestei definiții, sunt permise şi arce de genul:&nbsp;<code>u=(x,x)</code>&nbsp;unde&nbsp;<code>x&isin;V</code>; aceste arce se numesc&nbsp;<strong>bucle</strong>.</p>
                  <p><strong>Exemplu:</strong></p>
                  <img src="graf-orientat-1.png">
                  <p><strong>Definiție.</strong>&nbsp;Se numeşte&nbsp;<strong>graf orientat</strong>&nbsp;o pereche ordonată de mulțimi notată&nbsp;<code>G=(V, U)</code>, unde:</p>
                  <p class="indented"><code>V</code>&nbsp;este o mulțime, finită şi nevidă, ale cărei elemente se numesc&nbsp;<strong>noduri</strong>&nbsp;sau&nbsp;<strong>v&acirc;rfuri</strong>;</p>
                  <p class="indented"><code>U</code>&nbsp;este o familie de perechi ordonate de elemente din&nbsp;<code>V</code>, numită familia de&nbsp;<strong>arce</strong>.</p>
                  <p>Această definiție diferă de cea anterioară prin faptul ca acum nu numai că se admit bucle, dar se admit şi mai multe arce identice.</p>
                  <p><strong>Exemplu:</strong></p>
                  <img src="graf-orientat-2.png">
                  <p>Observăm că există trei arce&nbsp;<code>(6,2)</code>.</p>
                  <p><strong>Observație.</strong>&nbsp;Dacă &icirc;ntr-un graf orientat numărul arcelor identice nu depăşeşte numărul&nbsp;<code>p</code>, atunci se numeşte&nbsp;<strong>p-graf</strong>. Graful de mai sus este un&nbsp;<strong>3-graf</strong>.</p>
              <h1>Grade</h1>
                <p><strong>Definiție.</strong>&nbsp;Fie&nbsp;<code>G=(V, U)</code>&nbsp;un graf orientat și&nbsp;<code>x</code>&nbsp;un nod al său.</p>
                <p class="indented">Se numeşte&nbsp;<strong>grad exterior</strong>&nbsp;al nodului&nbsp;<code>x</code>, numărul arcelor de forma&nbsp;<code>(x,y)</code>&nbsp;(adică numărul arcelor care ies din&nbsp;<code>x</code>), notat&nbsp;<code>d</code><sup><code>+</code></sup><code>(x)</code>.</p>
                <p class="indented">Se numeşte&nbsp;<strong>grad interior</strong>&nbsp;al nodului&nbsp;<code>x</code>, numărul arcelor de forma&nbsp;<code>(y,x)</code>&nbsp;(adică numărul arcelor care intră &icirc;n&nbsp;<code>x</code>), notat&nbsp;<code>d</code><sup><code>-</code></sup><code>(x)</code>.</p>
                <p><strong>Exemplu:</strong></p>
                <p>Pentru graful alăturat:</p>
                <p><code>d</code><sup><code>+</code></sup><code>(2)=2</code></p>
                <p><code>d</code><sup><code>-</code></sup><code>(2)=3</code></p>
                <p><strong>Teoremă:</strong>&nbsp;&Icirc;ntr-un graf orientat, suma gradelor exterioare a tuturor nodurilor este egală cu suma gradelor interioare a tuturor nodurilor și cu numărul de arce.</p>
                <p>Un nod&nbsp;<code>x</code>&nbsp;se numește&nbsp;<strong>izolat</strong>&nbsp;dacă&nbsp;<code>d</code><sup><code>+</code></sup><code>(x)=d</code><sup><code>-</code></sup><code>(x)=0</code>&nbsp;(are gradul interior și gradul exterior egal cu&nbsp;<code>0</code>).</p>
                <img src="graf-orientat (1).png">
              <h1>Reprezentarea grafurilor orientate</h1>
                <h2>Matricea de adiacență</h2>
                  <p>Fie&nbsp;<code>G=(V,U)</code>&nbsp;un graf orientat cu&nbsp;<code>n</code>&nbsp;noduri, &icirc;n care nu există mai multe arce de la un nod la altul. Matricea de adiacență a grafului este o matrice cu&nbsp;<code>n</code>&nbsp;linii și&nbsp;<code>n</code>&nbsp;coloane și elemente&nbsp;<code>0</code>&nbsp;sau&nbsp;<code>1</code>, astfel:</p>
                  <p class="indented"><code>A</code><sub><code>i,j</code></sub><code>=1</code>&nbsp;dacă există arcul&nbsp;<code>(i,j)</code></p>
                  <p class="indented"><code>A</code><sub><code>i,j</code></sub><code>=0</code>&nbsp;dacă există nu arcul&nbsp;<code>(i,j)</code></p>
                  <img src="graf-orientat (2).png">
                  <p>Pentru graful alăturat, matricea de adiacență este:</p>
                  <p>0 0 0 0 0 1</p>
                  <p>1 0 0 1 0 0</p>
                  <p>0 1 0 0 0 0</p>
                  <p>0 1 0 0 0 0</p>
                  <p>0 0 0 1 0 0</p>
                  <p>1 1 0 1 0 0</p>
                  <p>Observăm că matricea de adiacență:</p>
                  <p>** are zero pe diagonală (dacă &icirc;n graf nu avem bucle)<br />** nu este simetrică față de diagonala principală</p>
                  <p>Pentru reprezentarea &icirc;n memorie vom folosi un tablou bidimensional ale cărui dimensiuni sunt &icirc;n concordanță cu numărul de noduri din graf.</p>
                  <p>Considerăm un graf cu maxim&nbsp;<code>50</code>&nbsp;de noduri. &Icirc;n C/C++ vom avea declarația:</p>
                  <p><code>int A[51][51];</code></p>
                <h2>Lista de arce</h2>
                  <p>Lista de arce a unui graf orientat reprezintă o mulțime (familie, dacă arcele se pot repeta) ce conține toate arcele din graf.</p>
                  <img src="graf-orientat (3).png">
                  <p>Pentru graful alăturat, lista de arce este:</p>
                  <p><code>U={(1,6),(2,1),(2,4),(3,2),(4,2),(5,4),(6,1),(6,4)}</code></p>
                  <p>Pentru reprezentarea &icirc;n memorie putem folosi:</p>
                  <p class="indented">un tablou unidimensional cu elemente de tip&nbsp;<code>struct {int I,J;}</code></p>
                  <p class="indented">două tablouri unidimensionale cu elemente de tip&nbsp;<code>int</code></p>
                  <p class="indented">o listă alocată dinamic</p>
                  <p class="indented">etc.</p>
                <h2>Listele de adiacență</h2>
                  <p>Pentru un graf orientat cu&nbsp;<code>G=(V,U)</code>&nbsp;se va memora numărul de noduri&nbsp;<code>n</code>&nbsp;și apoi, pentru fiecare nod&nbsp;<code>x</code>, lista succesorilor lui&nbsp;<code>x</code>, adică nodurilor&nbsp;<code>y</code>&nbsp;cu proprietatea că există arcul&nbsp;<code>(x,y)</code>.</p>
                  <img src="graf-orientat (4).png">
                  <p>Pentru graful alăturat, listele de adiacență sunt:</p>
                  <p>1: 6</p>
                  <p>2: 1 4</p>
                  <p>3: 2</p>
                  <p>4: 2</p>
                  <p>5: 4</p>
                  <p>6: 1 2 4</p>
                  <p>La reprezentarea &icirc;n memorie trebui avut &icirc;n vedere că dimensiunile listelor de succesori sunt variabile. De aceea, este neeficientă utilizarea unor tablouri alocate static. Astfel, putem folosi:</p>
                  <p class="indented">un șir de&nbsp;<code>n</code>&nbsp;tablouri unidimensionale alocate dinamic;</p>
                  <p class="indented">un șir de&nbsp;<code>n</code>&nbsp;vectori din&nbsp;<span class="caps">STL</span>;</p>
                  <p class="indented">un șir de&nbsp;<code>n</code>&nbsp;liste simplu (dublu) &icirc;nlănțuite alocate dinamic.</p>
              <h1>Graf parțial, subgraf</h1>
                <p><strong>Definiție.</strong>&nbsp;Fie&nbsp;<code>G=(V, U)</code>&nbsp;un graf orientat. Se numeşte&nbsp;<strong>graf parțial</strong>&nbsp;al grafului&nbsp;<code>G</code>, graful orientat&nbsp;<code>G1=(V, U1)</code>, unde&nbsp;<code>U1 &sube; U</code>.</p>
                <p>Din definiție rezultă:</p>
                <p class="indented">Un graf parțial al unui graf orientat&nbsp;<code>G=(V,U)</code>, are aceeaşi mulțime de v&acirc;rfuri ca şi&nbsp;<code>G</code>, iar mulțimea arcelor este o submulțime a lui&nbsp;<code>U</code>&nbsp;sau chiar&nbsp;<code>U</code>.</p>
                <p class="indented">Fie&nbsp;<code>G=(V, U)</code>&nbsp;un graf orientat. Un graf parțial al grafului&nbsp;<code>G</code>, se obține păstr&acirc;nd v&acirc;rfurile şi<br />elimin&acirc;nd eventual nişte arce (se pot elimina şi toate arcele sau chiar nici unul).</p>
                <p><strong>Definiție.</strong>&nbsp;Fie&nbsp;<code>G=(V, U)</code>&nbsp;un graf orientat. Se numeşte&nbsp;<strong>subgraf</strong>&nbsp;al grafului&nbsp;<code>G</code>&nbsp;graful orientat&nbsp;<code>G1=(V1,U1)</code>&nbsp;unde&nbsp;<code>V1 &sube; V</code>&nbsp;iar&nbsp;<code>U1</code>&nbsp;conține toate arcele din&nbsp;<code>U</code>&nbsp;care au extremitățile &icirc;n&nbsp;<code>V1</code>.</p>
                <p>Din definiție rezultă:</p>
                <p class="indented">Fie&nbsp;<code>G=(V,U)</code>&nbsp;un graf orientat. Un subgraf al grafului&nbsp;<code>G</code>, se obține şterg&acirc;nd eventual anumite<br />v&acirc;rfuri şi odată cu acestea şi arcele care le admit ca extremitate (nu se pot şterge toate v&acirc;rfurile deoarece<br />s-ar obține un graf cu mulțimea v&acirc;rfurilor vidă).</p>
                <p><strong>Exemplu:</strong></p>
                <table class="table">
		                <tbody>
                      <tr>
			                  <td>Graful inițial</td>
			                  <td>Graf parțial</td>
			                  <td> Subgraf</td>
		                  </tr>
		                  <tr>
			                  <td> <img alt="" src="graf-orientat-3.png" style="margin:0px 0px 0px 0px"> </td>
			                  <td> <img alt="" src="graf-orientat-3-graf-partial.png" style="margin:0px 0px 0px 0px"> </td>
			                  <td> <img alt="" src="graf-orientat-3-subgraf.png" style="margin:0px 0px 0px 0px"> </td>
		                  </tr>
		                  <tr>
			                 <td> </td>
			                 <td> S-au eliminat arcele <code>(1,6)</code>, <code>(3,2)</code>, <code>(6,4)</code> </td>
		                   <td> S-a eliminat nodul <code>6</code> și toate arcele incidente cu el. </td>
		                  </tr>
                    </tbody>
                </table>
              <h1>Graf complet. Graf turneu.</h1>
                <p><strong>Definiție.</strong>&nbsp;Fie&nbsp;<code>G=(V, U)</code>&nbsp;un graf orientat. Graful&nbsp;<code>G</code>&nbsp;se numește&nbsp;<strong>graf complet</strong>&nbsp;dacă oricare două v&acirc;rfuri<br />distincte ale sale sunt adiacente.</p>
                <p>Două v&acirc;rfuri&nbsp;<code>x</code>&nbsp;și&nbsp;<code>y</code>&nbsp;sunt adiacente dacă:</p>
                <p class="indented">&icirc;ntre ele există arcul&nbsp;<code>(x,y)</code>, sau</p>
                <p class="indented">&icirc;ntre ele există arcul&nbsp;<code>(y,x)</code>, sau</p>
                <p class="indented">&icirc;ntre ele există arcele&nbsp;<code>(x,y)</code>&nbsp;şi&nbsp;<code>(y,x)</code>.</p>
                <p><strong>Exemplu:</strong></p>
                <img src="graf-orientat-3-complet.png">
                <p><strong>Teoremă:</strong>&nbsp;Numărul de grafuri orientate complete cu&nbsp;<code>n</code>&nbsp;noduri este&nbsp;<code>3</code><sup><code>n*(n-1)/2</code></sup>.</p>
                <p><strong>Definiție:</strong>&nbsp;Un graf orientat este&nbsp;<strong>turneu</strong>, dacă oricare ar fi două v&acirc;rfuri&nbsp;<code>i</code>&nbsp;şi&nbsp;<code>j</code>,&nbsp;<code>i&ne;j</code>, &icirc;ntre ele există un singur arc: arcul&nbsp;<code>(i,j)</code>&nbsp;sau arcul&nbsp;<code>(j,i)</code>.</p>
                <p><strong>Exemplu:</strong></p>
                <img src="graf-orientat-3-turneu.png">
                <p><strong>Proprietăți:</strong></p>
                <p class="indented">Orice graf turneu este graf complet.</p>
                <p class="indented">Avem&nbsp;<code>2</code><sup><code>n*(n-1)/2</code></sup>&nbsp;grafuri turneu cu&nbsp;<code>n</code>&nbsp;noduri.</p>
                <p class="indented">&Icirc;n orice graf turneu există un drum elementar care trece prin toate v&acirc;rfurile grafului.</p>
              <h1>Conexitate</h1>
                <h2>Lanț. Drum</h2>
                  <p><strong>Definiție:</strong>&nbsp;Fie&nbsp;<code>G=(V, U)</code>&nbsp;un graf orientat. Se numește&nbsp;<strong>lanț</strong>, &icirc;n graful G, o succesiune de arce, notată<br /><code>L = (u</code><sub><code>1</code></sub><code> , u</code><sub><code>2</code></sub><code> ,..., u</code><sub><code>k</code></sub><code>)</code>&nbsp;cu proprietatea ca oricare două arce consecutive au o extremitate comună (nu are importanță orientarea arcelor).</p>
                  <p>sau</p>
                  <p><strong>Definiție:</strong>&nbsp;Fie&nbsp;<code>G=(V, U)</code>&nbsp;un graf orientat. Se numește&nbsp;<strong>lanț</strong>, &icirc;n graful G, o succesiune de noduri, notată<br /><code>L = (x</code><sub><code>1</code></sub><code> , x</code><sub><code>2</code></sub><code> ,..., x</code><sub><code>p</code></sub><code>)</code>&nbsp;cu proprietatea ca oricare două noduri consecutive sunt adiacente.</p>
                  <p>Lungimea unui lanț este egală cu numărul de arce din care este alcătuit.</p>
                  <p>Primul nod și ultimul nod dintr-un lanț formează extremitățile lanțului.</p>
                  <p><strong>Definiție.</strong>&nbsp;Fie&nbsp;<code>G=(V, U)</code>&nbsp;un graf orientat. Se numește&nbsp;<strong>drum</strong>&nbsp;&icirc;n graful&nbsp;<code>G</code>&nbsp;o succesiune de noduri, notată<br /><code>D = (x</code><sub><code>1</code></sub><code> , x</code><sub><code>2</code></sub><code> ,..., x</code><sub><code>k</code></sub><code>)</code>, cu proprietatea că pentru orice&nbsp;<code>1&le;i&lt;k</code>,&nbsp;<code>(x</code><sub><code>i</code></sub><code>,x</code><sub><code>i+1</code></sub><code>)</code>&nbsp;este arc &icirc;n&nbsp;<code>G</code>.</p>
                  <p>Lungimea unui drum este egală cu numărul de arce din care este alcătuit.</p>
                  <p>Pentru un drum&nbsp;<code>D = (x</code><sub><code>1</code></sub><code> , x</code><sub><code>2</code></sub><code> ,..., x</code><sub><code>k</code></sub><code>)</code>, nodurile&nbsp;<code>x</code><sub><code>1</code></sub>&nbsp;și&nbsp;<code>x</code><sub><code>k</code></sub>&nbsp;reprezintă extremitățile &ndash; inițială, respectiv finală.</p>
                  <p>Un lanț (drum) se numește&nbsp;<strong>elementar</strong>&nbsp;dacă &icirc;n el nu se repetă noduri. Un lanț (drum) se numește&nbsp;<strong>simplu</strong>&nbsp;dacă &icirc;n el nu se repetă arce.</p>
                  <img src="graf-orientat-3 (1).png">
                  <p><strong>Exemple</strong>&nbsp;&Icirc;n graful alăturat:</p>
                  <p><code>L=(5,4,2,6,1)</code>&nbsp;este un lanț elementar, dar nu este drum.<br /><code>D=(3,2,1,6,4)</code>&nbsp;este drum elementar.<br /><code>D=(3,2,1,6,2,4)</code>&nbsp;este drum neelementar, dar simplu.</p>
                <h2>Circuit</h2>
                  <p><strong>Definiție:</strong>&nbsp;Se numește&nbsp;<strong>circuit</strong>&nbsp;un drum simplu &icirc;n care extremitatea inițială și finală sunt egale. Se numește&nbsp;<strong>circuit elementar</strong>&nbsp;un circuit &icirc;n care, cu excepția extremităților, nu se repetă noduri.</p>
                  <p>Lungimea unui circuit este reprezentată de numărul de arce din care acesta este alcătuit.</p>
                  <img src="graf-orientat-3 (2).png">
                  <p><strong>Exemple</strong>&nbsp;&Icirc;n graful alăturat:</p>
                  <p><code>(1,6,2,1)</code>&nbsp;și&nbsp;<code>(1,6,4,2,1)</code>&nbsp;sunt circuite elementare.</p>
              <h1>Conexitate. Tare conexitate</h1>
                <p><strong>Definiții:</strong>&nbsp;Fie&nbsp;<code>G=(V,U)</code>&nbsp;un graf orientat.</p>
                <p>Graful se numește&nbsp;<strong>conex</strong>&nbsp;dacă &icirc;ntre oricare două noduri distincte există cel puțin un&nbsp;<strong>lanț</strong>.</p>
                <p>Se numește&nbsp;<strong>componentă conexă</strong>&nbsp;un subgraf conex și maximal cu această calitate &ndash; dacă am mai adauga un nod, n-ar mai fi conex.</p>
                <p>Graful se numește&nbsp;<strong>tare conex</strong>&nbsp;dacă &icirc;ntre oricare două noduri distincte există cel puțin un&nbsp;<strong>drum</strong>.</p>
                <p>Se numește&nbsp;<strong>componentă tare conexă</strong>&nbsp;un subgraf tare conex și maximal cu această calitate &ndash; dacă am mai adauga un nod, n-ar mai fi tare conex.</p>
              <h1>Graf hamiltonian. Graf eulerian</h1>
                <p><strong>Definiții:</strong>&nbsp;Fie un graf orientat&nbsp;<code>G=(V,U)</code>.</p>
                <p>Un drum elementar care conține toate nodurile grafului se numește&nbsp;<strong>drum hamiltonian</strong>.</p>
                <p>Un circuit elementar care conține toate nodurile grafului se numește&nbsp;<strong>circuit hamiltonian</strong>.</p>
                <p>Un graf care conține un circuit hamiltonian se numește&nbsp;<strong>graf hamiltonian</strong>.</p>
                <p><strong>Exemplu:</strong>&nbsp;Graful orientat desenat mai jos este hamiltonian, deoarece con ține circuitul hamiltonian&nbsp;<code>(2, 1, 5 , 6, 4, 3, 2)</code>.</p>
                <img src="graf-orientat-3-hamiltonian.png">
                <p><strong>Definiții:</strong>&nbsp;Fie un graf orientat&nbsp;<code>G=(V,U)</code>.</p>
                <p>Un drum care conține toate arcele grafului se numește&nbsp;<strong>drum eulerian</strong>.</p>
                <p>Un circuit care conține toate arcele grafului se numește&nbsp;<strong>circuit eulerian</strong>.</p>
                <p>Un graf care conține un circuit eulerian se numește&nbsp;<strong>graf eulerian</strong>.</p>
                <p><strong>Teoremă:</strong>&nbsp;Un graf fără noduri izolate este eulerian dacă și numai dacă este conex și pentru fiecare nod, gradul interior este egal cu cel exterior.</p>
                <p><strong>Exemplu:</strong>&nbsp;Graful orientat de mai jos este eulerian.</p>
                <img src="graf-orientat-3-eulerian.png">
             </div>


             <div class="textbox" id="TC">
               <p>Un graf orientat&nbsp;<code>G=(V,E)</code>&nbsp;este&nbsp;<strong>tare conex</strong>&nbsp;dacă pentru orice pereche de noduri distincte&nbsp;<code>(x,y)</code>&nbsp;există cel puțin un drum de la&nbsp;<code>x</code>&nbsp;la&nbsp;<code>y</code>&nbsp;și există cel puțin un drum de la&nbsp;<code>y</code>&nbsp;la&nbsp;<code>x</code>.</p>
               <p>Pentru un graf orientat, se numește componentă&nbsp;<strong>tare conexă</strong>&nbsp;un subgraf tare conex maximal &ndash; prin adăugarea a &icirc;ncă unui nod, subgraful obținut nu mai este tare conex.</p>
               <p><strong>Exemplu:</strong></p>
               <img src="graf.png">
               <p>Graful de mai sus nu este tare conex. El are trei componente tare conexe.</p>
               <h1>Verificare tare conexității. Determinarea componentelor tare conexe</h1>
                <p>Verificare tare conexității unui graf orientat poate fi privită ca un caz particular al determinării componentelor tare conexe, deoarece, dacă graful are o singură componentă tare conexă atunci el este tare conex. &Icirc;n continuare vom vedea două metode de determinare a componentelor tare conexe. Ambele folosesc noțiunea de graf transpus, pe care o definim &icirc;n continuare:</p>
                <p><strong>Definiție:</strong>&nbsp;Fie&nbsp;<code>G=(V,E)</code>&nbsp;un graf orientat. Se numește&nbsp;<strong>graf transpus al lui&nbsp;<code>G</code></strong>&nbsp;graful orientat&nbsp;<code>GT=(V,ET)</code>, cu aceleași mulțimea a nodurilor și pentru orice pereche de noduri are loc:&nbsp;<code>(x,y)</code>&nbsp;este arc &icirc;n G dacă și numai dacă&nbsp;<code>(y,x)</code>&nbsp;este arc &icirc;n&nbsp;<code>GT</code>.</p>
                <p><strong>Exemplu</strong></p>
                <table class="table">
		             <tbody>
                  <tr>
			             <td> Graf orientat inițial </td>
			             <td> Graful orientat transpus </td>
		              </tr>
		               <tr>
			              <td> <img alt="" src="graf-1.png" style="margin:0px 0px 0px 0px"> </td>
			              <td> <img alt="" src="graf-1-transpus.png" style="margin:0px 0px 0px 0px"> </td>
		               </tr>
                 </tbody>
                </table>
                <p>Să observăm că pentru două noduri oarecare&nbsp;<code>x</code>,&nbsp;<code>y</code>:</p>
                <p class="indented">existența unui drum de la&nbsp;<code>x</code>&nbsp;la&nbsp;<code>y</code>&nbsp;poate fi determinată cu o parcurgere (de exemplu &icirc;n ad&acirc;ncime) &icirc;n graful&nbsp;<code>G</code>, pornind din nodul&nbsp;<code>x</code>;</p>
                <p class="indented">existența unui drum de la&nbsp;<code>y</code>&nbsp;la&nbsp;<code>x</code>&nbsp;poate fi determinată cu o parcurgere &icirc;n graful&nbsp;<code>GT</code>, pornind tot din nodul&nbsp;<code>x</code>.</p>
                <h2>Algoritmul Plus-Minus</h2>
                  <p>Folosind observații de mai sus, pentru a determina componentele tare conexe folosim următorul algoritm, numit&nbsp;<strong>Plus-Minus</strong>:</p>
                  <p class="indented">pentru fiecare nod&nbsp;<code>x</code>&nbsp;al grafului care &icirc;ncă nu a fost plasat &icirc;ntr-o componentă tare conexă:</p>
                  <p class="indented">determinăm toate nodurile &icirc;n care se poate ajunge din&nbsp;<code>x</code>, folosind graful&nbsp;<code>G</code>&nbsp;și le marcăm &icirc;ntr-un tablou cu&nbsp;<em>plus</em>;</p>
                  <p class="indented">determinăm toate nodurile din care se poate ajunge &icirc;n&nbsp;<code>x</code>, folosind graful&nbsp;<code>GT</code>&nbsp;și le marcăm &icirc;ntr-un tablou cu&nbsp;<em>minus</em>;</p>
                  <p class="indented">nodurile marcate at&acirc;t cu&nbsp;<em>plus</em>, c&acirc;t și cu&nbsp;<em>minus</em>, &icirc;mpreună cu&nbsp;<code>x</code>&nbsp;formează o componentă tare conexă;</p>
                  <p><strong>Exemplu:</strong></p>
                  <p>Fie graful de mai sus. Să determinăm componenta tare conexă din care face parte nodul&nbsp;<code>6</code>:</p>
                  <table class="table">
		               <tbody>
                    <tr>
                     <td> Graful inițial </td>
                     <td> Graful transpus </td>
                    </tr>
                     <tr>
			                <td> <img alt="" src="graf-initial-parcurgere-6.png" style="margin:0px 0px 0px 0px"> </td>
			                <td> <img alt="" src="graf-transpus-parcurgere-6.png" style="margin:0px 0px 0px 0px"> </td>
		                 </tr>
		                 <tr>
			                <td> S-au marcat cu <em>plus</em> nodurile: <code>5 7 8</code> </td>
			                <td> S-au marcat cu <em>minus</em> nodurile: <code>1 2 3 4 5 7 8</code> </td>
		                 </tr>
                   </tbody>
                 </table>
                 <p>Nodurile marcate de două ori,&nbsp;<code>5 7 8</code>, &icirc;mpreună cu nodul inițial,&nbsp;<code>6</code>, formează o componentă tare conexă.</p>
                 <p><strong>Secvență C++:</strong></p>
                 <p class="indented"><code>n, a[][]</code>&nbsp;&ndash; numărul de noduri și matricea de adiacență</p>
                 <p class="indented"><code>nrc</code>&nbsp;&ndash; numărul de componente tare conexe</p>
                 <p class="indented"><code>ctc[]</code>&nbsp;&ndash; tablou pentru memorarea componentelor tare conexe:&nbsp;<code>ctc[i] = </code>&nbsp;numărul de ordine al componentei din care face parte nodul&nbsp;<code>i</code></p>
                 <p class="indented"><code>s[], p[]</code>&nbsp;&ndash; tablouri pentru marcare nodurilor vizitate &icirc;n timpul parcurgerilor</p>
                 <p class="indented">să observăm că graful inițial și cel transpus pot fi memorate prin aceeași matrice de adiacență</p>
                 <pre style="font-size:20px" contenteditable="true" editable="true">void df1(int x)
{
    s[x] = 1;
    for(int i =1 ; i &lt;= n ; i ++)
        if(s[i] == 0 &amp;&amp; a[x][i] == 1)
            df1(i);
}

void df2(int x)
{
    p[x] = 1;
    for(int i =1 ; i &lt;= n ; i ++)
        if(p[i] == 0 &amp;&amp; a[i][x] == 1)
            df2(i);
}

int main()
{
    .....
    for(int i = 1 ; i &lt;= n ; ++i)
        if(ctc[i] == 0)
        {
            for(int j = 1; j &lt;= n ; ++j)
                s[j] = p[j] = 0;
            nrc ++;
            df1(i); df2(i);
            for(int j = 1; j &lt;= n ; ++j)
                if(s[j] == 1 &amp;&amp; p[j] == 1)
                    ctc[j] = nrc;
        }
    ....
}</pre>
               <h2>Algoritmul lui Kosaraju</h2>
                <p>Alt algoritm, mai eficient, pentru determinarea componentelor tare conexe este&nbsp;<strong>Algoritmul lui Kosaraju</strong>.</p>
                <p>Să ne amintim că la parcurgerea &icirc;n ad&acirc;ncime se pot asocia nodurilor două momente de timp:</p>
                <p class="indented"><code>d[x]</code>&nbsp;&ndash; momentul c&acirc;nd nodul&nbsp;<code>x</code>&nbsp;este descoperit și adăugat pe stivă:&nbsp;<strong>timpul de descoperire</strong>&nbsp;a nodului</p>
                <p class="indented"><code>f[x]</code>&nbsp;&ndash; momentul c&acirc;nd se termină de vizitat succesorii lui&nbsp;<code>x</code>, iar nodul&nbsp;<code>x</code>&nbsp;se elimină de pe stivă:&nbsp;<strong>timpul de finalizare</strong>&nbsp;a nodului</p>
                <p>Aceste momente de timp vor fi numere naturale &icirc;ntre&nbsp;<code>1</code>&nbsp;și&nbsp;<code>2*n</code>, unde&nbsp;<code>n</code>&nbsp;este numărul de noduri din graf.</p>
                <p>Algoritmul lui Kosaraju este:</p>
                <p class="indented">determinăm graful transpus&nbsp;<code>GT</code></p>
                <p class="indented">parcurgem &icirc;n ad&acirc;ncime graful și determinăm pentru fiecare nod&nbsp;<code>x</code>&nbsp;timpul de finalizare&nbsp;<code>f[x]</code></p>
                <p class="indented">parcurgem &icirc;n ad&acirc;ncime graful transpus&nbsp;<code>GT</code>, dar considerăm nodurile &icirc;n ordinea descrescătoarea timpilor de finalizare</p>
                <p class="indented">nodurile din arborii de parcurgere obținuți reprezintă c&acirc;te o componentă tare conexă</p>
                <p><strong>Exemplu:</strong></p>
                <table class="table">
		             <tbody>
                  <tr>
			             <td> Graf orientat inițial </td>
			             <td> Graful orientat transpus </td>
		              </tr>
		              <tr>
			             <td> <img alt="" src="graf-1 (1).png" style="margin: 0px 0px 0px 0px"> </td>
			             <td> <img alt="" src="graf-1-transpus (1).png" style="margin: 0px 0px 0px 0px"> </td>
		              </tr>
                 </tbody>
                </table>
                <p>&Icirc;n urma parcurgerii &icirc;n ad&acirc;ncime a grafului inițial&nbsp;<code>G</code>&nbsp;nodurile &icirc;n ordinea finalizării sunt:&nbsp;<img style="margin:0px 0px 0px 0px"src="https://www.pbinfo.ro/resurse/9dc152/articole/grafuri/tare-conexitate/timpi-parcurgere-dfs.png" alt="" /></p>
                <p>Parcurgem graful transpus&nbsp;<code>GT</code>&nbsp;analiz&acirc;nd nodurile &icirc;n ordinea inversă a timpilor de finalizare:</p>
                <p class="indented">&icirc;ncepem cu nodul&nbsp;<code>1</code>; se vizitează nodurile&nbsp;<code>3 4</code>; se determină componenta tare conexă&nbsp;<code>{1,3,4}</code>;</p>
                <p class="indented">continuăm cu nodul&nbsp;<code>2</code>&nbsp;(nodurile&nbsp;<code>1</code>,&nbsp;<code>3</code>&nbsp;și&nbsp;<code>4</code>&nbsp;au fost vizitate mai devreme); nu se vizitează alte noduri; se determină componenta tare conexă&nbsp;<code>{2}</code>;</p>
                <p class="indented">continuăm cu nodul&nbsp;<code>5</code>; se vizitează nodurile&nbsp;<code>6 8 7</code>; se determină componenta tare conexă&nbsp;<code>{5, 6, 7, 8}</code>.</p>
                <img src="parcurgere-graf-transpus.png">
                <p><strong>Secvență C++:</strong></p>
                <pre style="font-size:20px"contenteditable="true" editable="true">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;vector&lt;int&gt; &gt; G, GT;

int n , m , contor , nrs;

vector&lt;bool&gt; V;
vector&lt;int&gt; S;

void read()
{
    cin &gt;&gt; n &gt;&gt; m;
    G = GT = vector&lt;vector&lt;int&gt;&gt;(n + 1);
    for(int i = 1 ; i &lt;= m ; i++)
    {
        int a , b;
        cin &gt;&gt; a &gt;&gt; b;
        G[a].push_back(b);
        GT[b].push_back(a);
    }

}

void dfs(int k)
{
    V[k] = true;
    for(auto x : G[k])
        if(!V[x])
            dfs(x);
    S.push_back(k);
}

void dfsGT(int k)
{
    V[k]=1;
    for(auto x: GT[k])
        if(! V[x])
            dfsGT(x);

}

int main()
{
    read();

    V = vector&lt;bool&gt; (n + 1, false);
    for(int i = 1 ; i &lt;= n ; i ++)
        if(! V[i])
            dfs(i);

    V = vector&lt;bool&gt; (n + 1, false);
    for(vector&lt;int&gt;::reverse_iterator it = S.rbegin() ; it != S.rend() ; it ++)
        if(!V[*it]) {
                contor ++;
                dfsGT(*it);
        }

    cout&lt;&lt;contor;
    return 0;
}</pre>
                <p>Complexitatea acestui algoritm este aceea a parcurgerii &icirc;n ad&acirc;ncime:&nbsp;<code>O(n</code><sup><code>2</code></sup><code>)</code>&nbsp;dacă memorăm graful prin matricea de adiacență,&nbsp;<code>O(n+m)</code>&nbsp;dacă memorăm graful prin liste de adiacență.</p>
             </div>


             <div class="textbox" id="MD">
               <p>Fie&nbsp;<span id="MathJax-Element-1-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-1" class="math"><span id="MathJax-Span-2" class="mrow"><span id="MathJax-Span-3" class="mi">G</span><span id="MathJax-Span-4" class="mo">=</span><span id="MathJax-Span-5" class="mo">(</span><span id="MathJax-Span-6" class="mi">V</span><span id="MathJax-Span-7" class="mo">,</span><span id="MathJax-Span-8" class="mi">U</span><span id="MathJax-Span-9" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">G=(V,U)</span></span>&nbsp;un graf orientat cu&nbsp;<span id="MathJax-Element-2-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-10" class="math"><span id="MathJax-Span-11" class="mrow"><span id="MathJax-Span-12" class="mi">n</span></span></span><span class="MJX_Assistive_MathML">n</span></span>&nbsp;noduri. Algoritmul Roy-Warshall construiește matricea drumurilor:&nbsp;<span id="MathJax-Element-3-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-13" class="math"><span id="MathJax-Span-14" class="mrow"><span id="MathJax-Span-15" class="mi">D</span></span></span><span class="MJX_Assistive_MathML">D</span></span>&nbsp;cu&nbsp;<span id="MathJax-Element-4-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-16" class="math"><span id="MathJax-Span-17" class="mrow"><span id="MathJax-Span-18" class="mi">n</span></span></span><span class="MJX_Assistive_MathML">n</span></span>&nbsp;linii și&nbsp;<span id="MathJax-Element-5-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-19" class="math"><span id="MathJax-Span-20" class="mrow"><span id="MathJax-Span-21" class="mi">n</span></span></span><span class="MJX_Assistive_MathML">n</span></span>&nbsp;coloane, &icirc;n care:</p>
               <div class="MathJax_Display"><span id="MathJax-Element-6-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: center; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mtable columnalign=&quot;left left&quot; rowspacing=&quot;.2em&quot; columnspacing=&quot;1em&quot; displaystyle=&quot;false&quot;&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mtext&gt;dac&amp;#x103;&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mtext&gt;&amp;#xA0;sau nu exist&amp;#x103; drum de la&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mtext&gt;&amp;#xA0;la&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mtext&gt;dac&amp;#x103;&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;&amp;#x2260;&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mtext&gt;&amp;#xA0;&amp;#x219;i exist&amp;#x103; drum de la&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mtext&gt;&amp;#xA0;la&amp;#xA0;&lt;/mtext&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&quot;true&quot; stretchy=&quot;true&quot; symmetric=&quot;true&quot;&gt;&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-22" class="math"><span id="MathJax-Span-23" class="mrow"><span id="MathJax-Span-24" class="msubsup"><span id="MathJax-Span-25" class="mi">D</span><span id="MathJax-Span-26" class="texatom"><span id="MathJax-Span-27" class="mrow"><span id="MathJax-Span-28" class="mi">i</span><span id="MathJax-Span-29" class="mo">,</span><span id="MathJax-Span-30" class="mi">j</span></span></span></span><span id="MathJax-Span-31" class="mo">=</span><span id="MathJax-Span-32" class="mrow"><span id="MathJax-Span-33" class="mo">{</span><span id="MathJax-Span-34" class="mtable"><span id="MathJax-Span-35" class="mtd"><span id="MathJax-Span-36" class="mrow"><span id="MathJax-Span-37" class="mn">0</span></span></span><span id="MathJax-Span-49" class="mtd"><span id="MathJax-Span-50" class="mrow"><span id="MathJax-Span-51" class="mn">1</span></span></span><span id="MathJax-Span-38" class="mtd"><span id="MathJax-Span-39" class="mrow"><span id="MathJax-Span-40" class="mtext">dacă&nbsp;</span><span id="MathJax-Span-41" class="mi">i</span><span id="MathJax-Span-42" class="mo">=</span><span id="MathJax-Span-43" class="mi">j</span><span id="MathJax-Span-44" class="mtext">&nbsp;sau nu există&nbsp;drum de la&nbsp;</span><span id="MathJax-Span-45" class="mi">i</span><span id="MathJax-Span-46" class="mtext">&nbsp;la&nbsp;</span><span id="MathJax-Span-47" class="mi">j</span><span id="MathJax-Span-48" class="mo">,</span></span></span><span id="MathJax-Span-52" class="mtd"><span id="MathJax-Span-53" class="mrow"><span id="MathJax-Span-54" class="mtext">dacă&nbsp;</span><span id="MathJax-Span-55" class="mi">i</span><span id="MathJax-Span-56" class="mo">&ne;</span><span id="MathJax-Span-57" class="mi">j</span><span id="MathJax-Span-58" class="mtext">&nbsp;și există&nbsp;drum de la&nbsp;</span><span id="MathJax-Span-59" class="mi">i</span><span id="MathJax-Span-60" class="mtext">&nbsp;la&nbsp;</span><span id="MathJax-Span-61" class="mi">j</span></span></span></span><span id="MathJax-Span-62" class="mo"></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">Di,j={0dacă&nbsp;i=j&nbsp;sau nu există drum de la&nbsp;i&nbsp;la&nbsp;j,1dacă&nbsp;i&ne;j&nbsp;și există drum de la&nbsp;i&nbsp;la&nbsp;j</span></span></div>
                 <p>&nbsp;</p>
                 <p>Conform definiției de mai sus, &icirc;n matricea drumurilor, elementele cu indici egali vor avea &icirc;ntotdeauna valoarea&nbsp;<span id="MathJax-Element-7-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-63" class="math"><span id="MathJax-Span-64" class="mrow"><span id="MathJax-Span-65" class="mn">0</span></span></span><span class="MJX_Assistive_MathML">0</span></span>. Alternativ, putem accepta și elemente&nbsp;<span id="MathJax-Element-8-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-66" class="math"><span id="MathJax-Span-67" class="mrow"><span id="MathJax-Span-68" class="msubsup"><span id="MathJax-Span-69" class="mi">D</span><span id="MathJax-Span-70" class="texatom"><span id="MathJax-Span-71" class="mrow"><span id="MathJax-Span-72" class="mi">i</span><span id="MathJax-Span-73" class="mo">,</span><span id="MathJax-Span-74" class="mi">i</span></span></span></span><span id="MathJax-Span-75" class="mo">=</span><span id="MathJax-Span-76" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">Di,i=1</span></span>, &icirc;nțeleg&acirc;nd prin asta că există un circuit care conține nodul&nbsp;<span id="MathJax-Element-9-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-77" class="math"><span id="MathJax-Span-78" class="mrow"><span id="MathJax-Span-79" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>.</p>
                 <p>Pentru a construi această matrice, se pornește de la matricea de adiacență și i se aplică o serie de transformări, pornind de la următoarea idee: dacă nu există drum de la&nbsp;<span id="MathJax-Element-10-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-80" class="math"><span id="MathJax-Span-81" class="mrow"><span id="MathJax-Span-82" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-11-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-83" class="math"><span id="MathJax-Span-84" class="mrow"><span id="MathJax-Span-85" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>, dar există drum de la&nbsp;<span id="MathJax-Element-12-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-86" class="math"><span id="MathJax-Span-87" class="mrow"><span id="MathJax-Span-88" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-13-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-89" class="math"><span id="MathJax-Span-90" class="mrow"><span id="MathJax-Span-91" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>&nbsp;și drum de la&nbsp;<span id="MathJax-Element-14-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-92" class="math"><span id="MathJax-Span-93" class="mrow"><span id="MathJax-Span-94" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-15-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-95" class="math"><span id="MathJax-Span-96" class="mrow"><span id="MathJax-Span-97" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>, atunci va exista și drum de la&nbsp;<span id="MathJax-Element-16-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-98" class="math"><span id="MathJax-Span-99" class="mrow"><span id="MathJax-Span-100" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-17-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-101" class="math"><span id="MathJax-Span-102" class="mrow"><span id="MathJax-Span-103" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>, prin reuniunea celor două drumuri existente.</p>
                 <p>Mai exact:</p>
                 <p class="indented">inițial avem numai drumurile care nu au noduri intermediare (arcele)</p>
                 <p class="indented">determinăm toate drumurile care &icirc;l au eventual ca nod intermediar pe&nbsp;<span id="MathJax-Element-18-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-104" class="math"><span id="MathJax-Span-105" class="mrow"><span id="MathJax-Span-106" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">1</span></span></p>
                 <p class="indented">>determinăm toate drumurile care au noduri intermediare numai din mulțimea&nbsp;<span id="MathJax-Element-19-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-107" class="math"><span id="MathJax-Span-108" class="mrow"><span id="MathJax-Span-109" class="mrow"><span id="MathJax-Span-110" class="mo">{</span><span id="MathJax-Span-111" class="mrow"><span id="MathJax-Span-112" class="mn">1</span><span id="MathJax-Span-113" class="mo">,</span><span id="MathJax-Span-114" class="mn">2</span></span><span id="MathJax-Span-115" class="mo">}</span></span></span></span><span class="MJX_Assistive_MathML">{1,2}</span></span></p>
                 <p class="indented">determinăm toate drumurile care au noduri intermediare numai din mulțimea&nbsp;<span id="MathJax-Element-20-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-116" class="math"><span id="MathJax-Span-117" class="mrow"><span id="MathJax-Span-118" class="mrow"><span id="MathJax-Span-119" class="mo">{</span><span id="MathJax-Span-120" class="mrow"><span id="MathJax-Span-121" class="mn">1</span><span id="MathJax-Span-122" class="mo">,</span><span id="MathJax-Span-123" class="mn">2</span><span id="MathJax-Span-124" class="mo">,</span><span id="MathJax-Span-125" class="mn">3</span></span><span id="MathJax-Span-126" class="mo">}</span></span></span></span><span class="MJX_Assistive_MathML">{1,2,3}</span></span><br />&hellip;</p>
                 <p class="indented">pentru un&nbsp;<span id="MathJax-Element-21-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-127" class="math"><span id="MathJax-Span-128" class="mrow"><span id="MathJax-Span-129" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>&nbsp;oarecare, determinăm toate drumurile care au noduri intermediare numai din mulțimea&nbsp;<span id="MathJax-Element-22-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mo&gt;&amp;#x2026;&lt;/mo&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-130" class="math"><span id="MathJax-Span-131" class="mrow"><span id="MathJax-Span-132" class="mrow"><span id="MathJax-Span-133" class="mo">{</span><span id="MathJax-Span-134" class="mrow"><span id="MathJax-Span-135" class="mn">1</span><span id="MathJax-Span-136" class="mo">,</span><span id="MathJax-Span-137" class="mn">2</span><span id="MathJax-Span-138" class="mo">,</span><span id="MathJax-Span-139" class="mo">&hellip;</span><span id="MathJax-Span-140" class="mo">,</span><span id="MathJax-Span-141" class="mi">k</span></span><span id="MathJax-Span-142" class="mo">}</span></span></span></span><span class="MJX_Assistive_MathML">{1,2,&hellip;,k}</span></span>. Pentru aceasta, vom căuta toate perechile de noduri&nbsp;<span id="MathJax-Element-23-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-143" class="math"><span id="MathJax-Span-144" class="mrow"><span id="MathJax-Span-145" class="mi">i</span><span id="MathJax-Span-146" class="mo">,</span><span id="MathJax-Span-147" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">i,j</span></span>&nbsp;astfel &icirc;nc&acirc;t&nbsp;<span id="MathJax-Element-24-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-148" class="math"><span id="MathJax-Span-149" class="mrow"><span id="MathJax-Span-150" class="msubsup"><span id="MathJax-Span-151" class="mi">D</span><span id="MathJax-Span-152" class="texatom"><span id="MathJax-Span-153" class="mrow"><span id="MathJax-Span-154" class="mi">i</span><span id="MathJax-Span-155" class="mo">,</span><span id="MathJax-Span-156" class="mi">k</span></span></span></span><span id="MathJax-Span-157" class="mo">=</span><span id="MathJax-Span-158" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">Di,k=1</span></span>&nbsp;și&nbsp;<span id="MathJax-Element-25-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-159" class="math"><span id="MathJax-Span-160" class="mrow"><span id="MathJax-Span-161" class="msubsup"><span id="MathJax-Span-162" class="mi">D</span><span id="MathJax-Span-163" class="texatom"><span id="MathJax-Span-164" class="mrow"><span id="MathJax-Span-165" class="mi">k</span><span id="MathJax-Span-166" class="mo">,</span><span id="MathJax-Span-167" class="mi">j</span></span></span></span><span id="MathJax-Span-168" class="mo">=</span><span id="MathJax-Span-169" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">Dk,j=1</span></span>, de unde va rezulta că și&nbsp;<span id="MathJax-Element-26-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-170" class="math"><span id="MathJax-Span-171" class="mrow"><span id="MathJax-Span-172" class="msubsup"><span id="MathJax-Span-173" class="mi">D</span><span id="MathJax-Span-174" class="texatom"><span id="MathJax-Span-175" class="mrow"><span id="MathJax-Span-176" class="mi">i</span><span id="MathJax-Span-177" class="mo">,</span><span id="MathJax-Span-178" class="mi">j</span></span></span></span><span id="MathJax-Span-179" class="mo">=</span><span id="MathJax-Span-180" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">Di,j=1</span></span>.</p>
                 <h1>Secvența C++</h1>
                  <p>Secvență C++ &ndash; elementele de pe diagonală răm&acirc;n&nbsp;<code>0</code>:</p>
                  <pre style="font-size:20px"class="code_cpp cm-s-default" data-lang="text/x-c++src" contenteditable="true" editable="true"><span class="cm-comment">// a - matricea de adiacență</span>
<span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">k</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">k</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">k</span>)
    <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">i</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">i</span>)
        <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">j</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">j</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">j</span>)
            <span class="cm-keyword">if</span>( <span class="cm-variable">i</span> <span class="cm-operator">!=</span> <span class="cm-variable">j</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">a</span>[<span class="cm-variable">i</span>][<span class="cm-variable">j</span>] <span class="cm-operator">==</span> <span class="cm-number">0</span> <span class="cm-operator">&amp;&amp;</span>  <span class="cm-variable">a</span>[<span class="cm-variable">i</span>][<span class="cm-variable">k</span>] <span class="cm-operator">==</span> <span class="cm-number">1</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">a</span>[<span class="cm-variable">k</span>][<span class="cm-variable">j</span>] <span class="cm-operator">==</span> <span class="cm-number">1</span>)
                <span class="cm-variable">a</span>[<span class="cm-variable">i</span>][<span class="cm-variable">j</span>] <span class="cm-operator">=</span> <span class="cm-number">1</span>;</pre>
                  <p>O variantă mai condensată este următoarea:</p>
                  <pre style="font-size:20px"class="code_cpp cm-s-default" data-lang="text/x-c++src" contenteditable="true" editable="true"><span class="cm-comment">// D este matricea de adiacență</span>
<span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">k</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">k</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">k</span>)
    <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">i</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">i</span>)
        <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">j</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">j</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">j</span>)
            <span class="cm-keyword">if</span>( <span class="cm-variable">i</span> <span class="cm-operator">!=</span> <span class="cm-variable">j</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">a</span>[<span class="cm-variable">i</span>][<span class="cm-variable">j</span>] <span class="cm-operator">==</span> <span class="cm-number">0</span>)
                <span class="cm-variable">a</span>[<span class="cm-variable">i</span>][<span class="cm-variable">j</span>] <span class="cm-operator">=</span> <span class="cm-variable">a</span>[<span class="cm-variable">i</span>][<span class="cm-variable">k</span>] <span class="cm-operator">*</span> <span class="cm-variable">a</span>[<span class="cm-variable">k</span>][<span class="cm-variable">j</span>];
              </pre>
              <p>Următoarea versiune transformă în <code>1</code> și elementele de pe diagonală care corespund unor noduri care fac parte din cel puțin un circuit.</p>
              <pre style="font-size:20px"class="code_cpp cm-s-default" data-lang="text/x-c++src" contenteditable="true" editable="true"><span class="cm-comment">// D este matricea de adiacență</span>
<span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">k</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">k</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">k</span>)
    <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">i</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">i</span>)
        <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">j</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">j</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">j</span>)
            <span class="cm-keyword">if</span>(<span class="cm-variable">a</span>[<span class="cm-variable">i</span>][<span class="cm-variable">j</span>] <span class="cm-operator">==</span> <span class="cm-number">0</span>)
                <span class="cm-variable">a</span>[<span class="cm-variable">i</span>][<span class="cm-variable">j</span>] <span class="cm-operator">=</span> <span class="cm-variable">a</span>[<span class="cm-variable">i</span>][<span class="cm-variable">k</span>] <span class="cm-operator">*</span> <span class="cm-variable">a</span>[<span class="cm-variable">k</span>][<span class="cm-variable">j</span>];
              </pre>
              <h1>Reconstituirea drumurilor</h1>
               <p>Pentru reconstituirea drumurilor vom folosi at&acirc;t matricea drumurilor c&acirc;t și matricea de adiacență. Fie acestea&nbsp;<span id="MathJax-Element-27-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-181" class="math"><span id="MathJax-Span-182" class="mrow"><span id="MathJax-Span-183" class="mi">D</span></span></span><span class="MJX_Assistive_MathML">D</span></span>, respectiv&nbsp;<span id="MathJax-Element-28-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-184" class="math"><span id="MathJax-Span-185" class="mrow"><span id="MathJax-Span-186" class="mi">A</span></span></span><span class="MJX_Assistive_MathML">A</span></span>, iar reconstituirea se bazează pe următorul algoritm recursiv, de tip Divide-et-Impera:
               </p>
               <p class="indented">reconstituim drumul de la&nbsp;<span id="MathJax-Element-29-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-187" class="math"><span id="MathJax-Span-188" class="mrow"><span id="MathJax-Span-189" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-30-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-190" class="math"><span id="MathJax-Span-191" class="mrow"><span id="MathJax-Span-192" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>&nbsp;&ndash; știm că&nbsp;<span id="MathJax-Element-31-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-193" class="math"><span id="MathJax-Span-194" class="mrow"><span id="MathJax-Span-195" class="msubsup"><span id="MathJax-Span-196" class="mi">D</span><span id="MathJax-Span-197" class="texatom"><span id="MathJax-Span-198" class="mrow"><span id="MathJax-Span-199" class="mi">i</span><span id="MathJax-Span-200" class="mo">,</span><span id="MathJax-Span-201" class="mi">j</span></span></span></span><span id="MathJax-Span-202" class="mo">=</span><span id="MathJax-Span-203" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">Di,j=1</span></span>:
               </p>
               <p class="indented">dacă există arc de la&nbsp;<span id="MathJax-Element-32-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-204" class="math"><span id="MathJax-Span-205" class="mrow"><span id="MathJax-Span-206" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-33-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-207" class="math"><span id="MathJax-Span-208" class="mrow"><span id="MathJax-Span-209" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>&nbsp;(adică&nbsp;<span id="MathJax-Element-34-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-210" class="math"><span id="MathJax-Span-211" class="mrow"><span id="MathJax-Span-212" class="msubsup"><span id="MathJax-Span-213" class="mi">A</span><span id="MathJax-Span-214" class="texatom"><span id="MathJax-Span-215" class="mrow"><span id="MathJax-Span-216" class="mi">i</span><span id="MathJax-Span-217" class="mo">,</span><span id="MathJax-Span-218" class="mi">j</span></span></span></span><span id="MathJax-Span-219" class="mo">=</span><span id="MathJax-Span-220" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">Ai,j=1</span></span>&nbsp;), atunci acest arc reprezintă și drumul căutat
               </p>
               <p class="indented">dacă nu există arc, căutăm un nod&nbsp;<code>k</code>&nbsp;pentru care&nbsp;<span id="MathJax-Element-35-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-221" class="math"><span id="MathJax-Span-222" class="mrow"><span id="MathJax-Span-223" class="msubsup"><span id="MathJax-Span-224" class="mi">D</span><span id="MathJax-Span-225" class="texatom"><span id="MathJax-Span-226" class="mrow"><span id="MathJax-Span-227" class="mi">i</span><span id="MathJax-Span-228" class="mo">,</span><span id="MathJax-Span-229" class="mi">k</span></span></span></span><span id="MathJax-Span-230" class="mo">=</span><span id="MathJax-Span-231" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">Di,k=1</span></span>&nbsp;și&nbsp;<span id="MathJax-Element-36-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-232" class="math"><span id="MathJax-Span-233" class="mrow"><span id="MathJax-Span-234" class="msubsup"><span id="MathJax-Span-235" class="mi">D</span><span id="MathJax-Span-236" class="texatom"><span id="MathJax-Span-237" class="mrow"><span id="MathJax-Span-238" class="mi">k</span><span id="MathJax-Span-239" class="mo">,</span><span id="MathJax-Span-240" class="mi">j</span></span></span></span><span id="MathJax-Span-241" class="mo">=</span><span id="MathJax-Span-242" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">Dk,j=1</span></span>&nbsp;și reconstituim prin apeluri recursive drumurile de la&nbsp;<span id="MathJax-Element-37-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-243" class="math"><span id="MathJax-Span-244" class="mrow"><span id="MathJax-Span-245" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-38-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-246" class="math"><span id="MathJax-Span-247" class="mrow"><span id="MathJax-Span-248" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>&nbsp;și de la&nbsp;<span id="MathJax-Element-39-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-249" class="math"><span id="MathJax-Span-250" class="mrow"><span id="MathJax-Span-251" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-40-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-252" class="math"><span id="MathJax-Span-253" class="mrow"><span id="MathJax-Span-254" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>.
               </p>
             </div>


             <div class="textbox" id="ARF">
              <h1>Drumuri de cost minim într-un graf orientat</h1>
                <p>Fie&nbsp;<span id="MathJax-Element-1-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-1" class="math"><span id="MathJax-Span-2" class="mrow"><span id="MathJax-Span-3" class="mi">G</span><span id="MathJax-Span-4" class="mo">=</span><span id="MathJax-Span-5" class="mo">(</span><span id="MathJax-Span-6" class="mi">V</span><span id="MathJax-Span-7" class="mo">,</span><span id="MathJax-Span-8" class="mi">U</span><span id="MathJax-Span-9" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">G=(V,U)</span></span>&nbsp;un graf orientat ponderat &ndash; &icirc;n care fiecare arc are asociată o valoare reală numită pondere sau cost, de regulă pozitivă, cu noduri numerotate de la&nbsp;<span id="MathJax-Element-2-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-10" class="math"><span id="MathJax-Span-11" class="mrow"><span id="MathJax-Span-12" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">1</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-3-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-13" class="math"><span id="MathJax-Span-14" class="mrow"><span id="MathJax-Span-15" class="mi">n</span></span></span><span class="MJX_Assistive_MathML">n</span></span>.
                </p>
                <p>Se dorește determinarea pentru fiecare pereche de noduri&nbsp;<span id="MathJax-Element-4-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-16" class="math"><span id="MathJax-Span-17" class="mrow"><span id="MathJax-Span-18" class="mi">x</span></span></span><span class="MJX_Assistive_MathML">x</span></span>&nbsp;<span id="MathJax-Element-5-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-19" class="math"><span id="MathJax-Span-20" class="mrow"><span id="MathJax-Span-21" class="mi">y</span></span></span><span class="MJX_Assistive_MathML">y</span></span>, dacă există, a unui drum de cost minim &ndash; &icirc;n care suma costurilor asociate arcelor care definesc drumul este minimă.
                </p>
                <p>Algoritmul pornește&nbsp;<strong>matricea costurilor</strong>&nbsp;,&nbsp;<span id="MathJax-Element-6-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-22" class="math"><span id="MathJax-Span-23" class="mrow"><span id="MathJax-Span-24" class="mi">A</span></span></span><span class="MJX_Assistive_MathML">A</span></span>&nbsp;&ndash; &icirc;n care:
                </p>
                <img src="86374f1df4eea4abd0ea57da019fea1e.png">
                <p>&Icirc;n reprezentarea &icirc;n memorie,&nbsp;<span id="MathJax-Element-8-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x221E;&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-73" class="math"><span id="MathJax-Span-74" class="mrow"><span id="MathJax-Span-75" class="mi">&infin;</span></span></span><span class="MJX_Assistive_MathML">&infin;</span></span>&nbsp;va fi &icirc;nlocuit cu o valoare numerică mare. &Icirc;n C++, aceasta poate fi&nbsp;<code>INF = 0x3F3F3F3F</code>, av&acirc;nd următoarele avantaje:
                </p>
                <p class="indented"><code>INF</code>&nbsp;se reprezintă &icirc;n tipul&nbsp;<code>int</code>&nbsp;(pe 32 de biți cu semn) și este mai mare dec&acirc;t&nbsp;<code>1.000.000.000</code></p>
                <p class="indented">suma&nbsp;<code>INF + INF</code>&nbsp;nu depășește limita maximă a tipului&nbsp;<code>int</code>, deci nu va face overflow.</>
                <p>Prin algoritmul Roy-Floyd matricea va fi transformată, astfel &icirc;nc&acirc;t la final va avea următoarea semnificație:</p>
                <img src="8672c2f3bf2f38bc4b740fdc996d5951.png">
              <h1>Justificare algorimului</h1>
                <p>Pentru graful&nbsp;<span id="MathJax-Element-10-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-119" class="math"><span id="MathJax-Span-120" class="mrow"><span id="MathJax-Span-121" class="mi">G</span><span id="MathJax-Span-122" class="mo">=</span><span id="MathJax-Span-123" class="mo">(</span><span id="MathJax-Span-124" class="mi">V</span><span id="MathJax-Span-125" class="mo">,</span><span id="MathJax-Span-126" class="mi">U</span><span id="MathJax-Span-127" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">G=(V,U)</span></span>&nbsp;, cu noduri numerotate de la&nbsp;<span id="MathJax-Element-11-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-128" class="math"><span id="MathJax-Span-129" class="mrow"><span id="MathJax-Span-130" class="mn">1</span></span></span><span class="MJX_Assistive_MathML">1</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-12-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-131" class="math"><span id="MathJax-Span-132" class="mrow"><span id="MathJax-Span-133" class="mi">n</span></span></span><span class="MJX_Assistive_MathML">n</span></span>, considerăm funcția&nbsp;<span id="MathJax-Element-13-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-134" class="math"><span id="MathJax-Span-135" class="mrow"><span id="MathJax-Span-136" class="mi">c</span><span id="MathJax-Span-137" class="mi">o</span><span id="MathJax-Span-138" class="mi">s</span><span id="MathJax-Span-139" class="mi">t</span><span id="MathJax-Span-140" class="mi">M</span><span id="MathJax-Span-141" class="mi">i</span><span id="MathJax-Span-142" class="mi">n</span><span id="MathJax-Span-143" class="mo">(</span><span id="MathJax-Span-144" class="mi">i</span><span id="MathJax-Span-145" class="mo">,</span><span id="MathJax-Span-146" class="mi">j</span><span id="MathJax-Span-147" class="mo">,</span><span id="MathJax-Span-148" class="mi">k</span><span id="MathJax-Span-149" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,j,k)</span></span>, reprezent&acirc;nd pentru fiecare pereche de noduri&nbsp;<span id="MathJax-Element-14-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-150" class="math"><span id="MathJax-Span-151" class="mrow"><span id="MathJax-Span-152" class="mi">i</span><span id="MathJax-Span-153" class="mo">,</span><span id="MathJax-Span-154" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">i,j</span></span>&nbsp;costul minim al unui drum de la&nbsp;<span id="MathJax-Element-15-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-155" class="math"><span id="MathJax-Span-156" class="mrow"><span id="MathJax-Span-157" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-16-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-158" class="math"><span id="MathJax-Span-159" class="mrow"><span id="MathJax-Span-160" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>&nbsp;av&acirc;nd noduri intermediare numai din mulțimea&nbsp;<span id="MathJax-Element-17-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mo&gt;&amp;#x2026;&lt;/mo&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-161" class="math"><span id="MathJax-Span-162" class="mrow"><span id="MathJax-Span-163" class="texatom"><span id="MathJax-Span-164" class="mrow"><span id="MathJax-Span-165" class="mn">1</span><span id="MathJax-Span-166" class="mo">,</span><span id="MathJax-Span-167" class="mn">2</span><span id="MathJax-Span-168" class="mo">,</span><span id="MathJax-Span-169" class="mo">&hellip;</span><span id="MathJax-Span-170" class="mo">,</span><span id="MathJax-Span-171" class="mi">k</span></span></span></span></span><span class="MJX_Assistive_MathML">1,2,&hellip;,k</span></span>. Atunci, problema revine la a determina pentru fiecare pereche de noduri&nbsp;<span id="MathJax-Element-18-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-172" class="math"><span id="MathJax-Span-173" class="mrow"><span id="MathJax-Span-174" class="mi">i</span><span id="MathJax-Span-175" class="mo">,</span><span id="MathJax-Span-176" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">i,j</span></span>&nbsp;valoarea&nbsp;<span id="MathJax-Element-19-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-177" class="math"><span id="MathJax-Span-178" class="mrow"><span id="MathJax-Span-179" class="mi">c</span><span id="MathJax-Span-180" class="mi">o</span><span id="MathJax-Span-181" class="mi">s</span><span id="MathJax-Span-182" class="mi">t</span><span id="MathJax-Span-183" class="mi">M</span><span id="MathJax-Span-184" class="mi">i</span><span id="MathJax-Span-185" class="mi">n</span><span id="MathJax-Span-186" class="mo">(</span><span id="MathJax-Span-187" class="mi">i</span><span id="MathJax-Span-188" class="mo">,</span><span id="MathJax-Span-189" class="mi">j</span><span id="MathJax-Span-190" class="mo">,</span><span id="MathJax-Span-191" class="mi">n</span><span id="MathJax-Span-192" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,j,n)</span></span>.</p>
                <p>Pentru fiecare pereche&nbsp;<span id="MathJax-Element-20-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-193" class="math"><span id="MathJax-Span-194" class="mrow"><span id="MathJax-Span-195" class="mi">i</span><span id="MathJax-Span-196" class="mo">,</span><span id="MathJax-Span-197" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">i,j</span></span>,&nbsp;<span id="MathJax-Element-21-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mtext&gt;costul arcului&amp;#xA0;&lt;/mtext&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-198" class="math"><span id="MathJax-Span-199" class="mrow"><span id="MathJax-Span-200" class="mi">c</span><span id="MathJax-Span-201" class="mi">o</span><span id="MathJax-Span-202" class="mi">s</span><span id="MathJax-Span-203" class="mi">t</span><span id="MathJax-Span-204" class="mi">M</span><span id="MathJax-Span-205" class="mi">i</span><span id="MathJax-Span-206" class="mi">n</span><span id="MathJax-Span-207" class="mo">(</span><span id="MathJax-Span-208" class="mi">i</span><span id="MathJax-Span-209" class="mo">,</span><span id="MathJax-Span-210" class="mi">j</span><span id="MathJax-Span-211" class="mo">,</span><span id="MathJax-Span-212" class="mn">0</span><span id="MathJax-Span-213" class="mo">)</span><span id="MathJax-Span-214" class="mo">=</span><span id="MathJax-Span-215" class="mtext">costul arcului&nbsp;</span><span id="MathJax-Span-216" class="mo">(</span><span id="MathJax-Span-217" class="mi">i</span><span id="MathJax-Span-218" class="mo">,</span><span id="MathJax-Span-219" class="mi">j</span><span id="MathJax-Span-220" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,j,0)=costul arcului&nbsp;(i,j)</span></span>, &ndash; drumul de la&nbsp;<span id="MathJax-Element-22-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-221" class="math"><span id="MathJax-Span-222" class="mrow"><span id="MathJax-Span-223" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-23-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-224" class="math"><span id="MathJax-Span-225" class="mrow"><span id="MathJax-Span-226" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>&nbsp;nu conține noduri intermediare, iar pentru un&nbsp;<span id="MathJax-Element-24-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-227" class="math"><span id="MathJax-Span-228" class="mrow"><span id="MathJax-Span-229" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>&nbsp;oarecare,&nbsp;<span id="MathJax-Element-25-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-230" class="math"><span id="MathJax-Span-231" class="mrow"><span id="MathJax-Span-232" class="mi">c</span><span id="MathJax-Span-233" class="mi">o</span><span id="MathJax-Span-234" class="mi">s</span><span id="MathJax-Span-235" class="mi">t</span><span id="MathJax-Span-236" class="mi">M</span><span id="MathJax-Span-237" class="mi">i</span><span id="MathJax-Span-238" class="mi">n</span><span id="MathJax-Span-239" class="mo">(</span><span id="MathJax-Span-240" class="mi">i</span><span id="MathJax-Span-241" class="mo">,</span><span id="MathJax-Span-242" class="mi">j</span><span id="MathJax-Span-243" class="mo">,</span><span id="MathJax-Span-244" class="mi">k</span><span id="MathJax-Span-245" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,j,k)</span></span>&nbsp;poate fi una dintre următoarele valori:</p>
                <p class="indented">drumul de la&nbsp;<span id="MathJax-Element-26-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-246" class="math"><span id="MathJax-Span-247" class="mrow"><span id="MathJax-Span-248" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-27-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-249" class="math"><span id="MathJax-Span-250" class="mrow"><span id="MathJax-Span-251" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>&nbsp;nu trece prin nodul&nbsp;<span id="MathJax-Element-28-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-252" class="math"><span id="MathJax-Span-253" class="mrow"><span id="MathJax-Span-254" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>:&nbsp;<span id="MathJax-Element-29-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-255" class="math"><span id="MathJax-Span-256" class="mrow"><span id="MathJax-Span-257" class="mi">c</span><span id="MathJax-Span-258" class="mi">o</span><span id="MathJax-Span-259" class="mi">s</span><span id="MathJax-Span-260" class="mi">t</span><span id="MathJax-Span-261" class="mi">M</span><span id="MathJax-Span-262" class="mi">i</span><span id="MathJax-Span-263" class="mi">n</span><span id="MathJax-Span-264" class="mo">(</span><span id="MathJax-Span-265" class="mi">i</span><span id="MathJax-Span-266" class="mo">,</span><span id="MathJax-Span-267" class="mi">j</span><span id="MathJax-Span-268" class="mo">,</span><span id="MathJax-Span-269" class="mi">k</span><span id="MathJax-Span-270" class="mo">&minus;</span><span id="MathJax-Span-271" class="mn">1</span><span id="MathJax-Span-272" class="mo">)</span></span></span></span></p>
                <p class="indented">drumul de la&nbsp;<span id="MathJax-Element-30-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-273" class="math"><span id="MathJax-Span-274" class="mrow"><span id="MathJax-Span-275" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-31-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-276" class="math"><span id="MathJax-Span-277" class="mrow"><span id="MathJax-Span-278" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>&nbsp;trece prin nodul&nbsp;<span id="MathJax-Element-32-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-279" class="math"><span id="MathJax-Span-280" class="mrow"><span id="MathJax-Span-281" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>&nbsp;&ndash; de la&nbsp;<span id="MathJax-Element-33-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-282" class="math"><span id="MathJax-Span-283" class="mrow"><span id="MathJax-Span-284" class="mi">i</span></span></span><span class="MJX_Assistive_MathML">i</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-34-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-285" class="math"><span id="MathJax-Span-286" class="mrow"><span id="MathJax-Span-287" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>&nbsp;și de la&nbsp;<span id="MathJax-Element-35-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-288" class="math"><span id="MathJax-Span-289" class="mrow"><span id="MathJax-Span-290" class="mi">k</span></span></span><span class="MJX_Assistive_MathML">k</span></span>&nbsp;la&nbsp;<span id="MathJax-Element-36-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-291" class="math"><span id="MathJax-Span-292" class="mrow"><span id="MathJax-Span-293" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">j</span></span>, cu noduri intermediare din mulțimea&nbsp;<span id="MathJax-Element-37-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mo&gt;&amp;#x2026;&lt;/mo&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-294" class="math"><span id="MathJax-Span-295" class="mrow"><span id="MathJax-Span-296" class="texatom"><span id="MathJax-Span-297" class="mrow"><span id="MathJax-Span-298" class="mn">1</span><span id="MathJax-Span-299" class="mo">,</span><span id="MathJax-Span-300" class="mn">2</span><span id="MathJax-Span-301" class="mo">,</span><span id="MathJax-Span-302" class="mo">&hellip;</span><span id="MathJax-Span-303" class="mo">,</span><span id="MathJax-Span-304" class="mi">k</span><span id="MathJax-Span-305" class="mo">&minus;</span><span id="MathJax-Span-306" class="mn">1</span></span></span></span></span><span class="MJX_Assistive_MathML">1,2,&hellip;,k&minus;1</span></span>:&nbsp;<span id="MathJax-Element-38-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: 400; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: 0px; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; orphans: 2; widows: 2; -webkit-text-stroke-width: 0px; background-color: #ffffff; text-decoration-style: initial; text-decoration-color: initial; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-307" class="math"><span id="MathJax-Span-308" class="mrow"><span id="MathJax-Span-309" class="mi">c</span><span id="MathJax-Span-310" class="mi">o</span><span id="MathJax-Span-311" class="mi">s</span><span id="MathJax-Span-312" class="mi">t</span><span id="MathJax-Span-313" class="mi">M</span><span id="MathJax-Span-314" class="mi">i</span><span id="MathJax-Span-315" class="mi">n</span><span id="MathJax-Span-316" class="mo">(</span><span id="MathJax-Span-317" class="mi">i</span><span id="MathJax-Span-318" class="mo">,</span><span id="MathJax-Span-319" class="mi">k</span><span id="MathJax-Span-320" class="mo">,</span><span id="MathJax-Span-321" class="mi">k</span><span id="MathJax-Span-322" class="mo">&minus;</span><span id="MathJax-Span-323" class="mn">1</span><span id="MathJax-Span-324" class="mo">)</span><span id="MathJax-Span-325" class="mo">+</span><span id="MathJax-Span-326" class="mi">c</span><span id="MathJax-Span-327" class="mi">o</span><span id="MathJax-Span-328" class="mi">s</span><span id="MathJax-Span-329" class="mi">t</span><span id="MathJax-Span-330" class="mi">M</span><span id="MathJax-Span-331" class="mi">i</span><span id="MathJax-Span-332" class="mi">n</span><span id="MathJax-Span-333" class="mo">(</span><span id="MathJax-Span-334" class="mi">k</span><span id="MathJax-Span-335" class="mo">,</span><span id="MathJax-Span-336" class="mi">j</span><span id="MathJax-Span-337" class="mo">,</span><span id="MathJax-Span-338" class="mi">k</span><span id="MathJax-Span-339" class="mo">&minus;</span><span id="MathJax-Span-340" class="mn">1</span><span id="MathJax-Span-341" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,k,k&minus;1)+costMin(k,j,k&minus;1)</span></span>.</p>
                <p>Atunci, pentru fiecare&nbsp;<span id="MathJax-Element-39-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-342" class="math"><span id="MathJax-Span-343" class="mrow"><span id="MathJax-Span-344" class="mi">c</span><span id="MathJax-Span-345" class="mi">o</span><span id="MathJax-Span-346" class="mi">s</span><span id="MathJax-Span-347" class="mi">t</span><span id="MathJax-Span-348" class="mi">M</span><span id="MathJax-Span-349" class="mi">i</span><span id="MathJax-Span-350" class="mi">n</span><span id="MathJax-Span-351" class="mo">(</span><span id="MathJax-Span-352" class="mi">i</span><span id="MathJax-Span-353" class="mo">,</span><span id="MathJax-Span-354" class="mi">j</span><span id="MathJax-Span-355" class="mo">,</span><span id="MathJax-Span-356" class="mi">k</span><span id="MathJax-Span-357" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,j,k)</span></span>&nbsp;se va alege minimul dintre cele două valori de mai sus:&nbsp;<span id="MathJax-Element-40-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-358" class="math"><span id="MathJax-Span-359" class="mrow"><span id="MathJax-Span-360" class="mi">c</span><span id="MathJax-Span-361" class="mi">o</span><span id="MathJax-Span-362" class="mi">s</span><span id="MathJax-Span-363" class="mi">t</span><span id="MathJax-Span-364" class="mi">M</span><span id="MathJax-Span-365" class="mi">i</span><span id="MathJax-Span-366" class="mi">n</span><span id="MathJax-Span-367" class="mo">(</span><span id="MathJax-Span-368" class="mi">i</span><span id="MathJax-Span-369" class="mo">,</span><span id="MathJax-Span-370" class="mi">j</span><span id="MathJax-Span-371" class="mo">,</span><span id="MathJax-Span-372" class="mi">k</span><span id="MathJax-Span-373" class="mo">)</span><span id="MathJax-Span-374" class="mo">=</span><span id="MathJax-Span-375" class="mi">m</span><span id="MathJax-Span-376" class="mi">i</span><span id="MathJax-Span-377" class="mi">n</span><span id="MathJax-Span-378" class="mo">(</span><span id="MathJax-Span-379" class="mi">c</span><span id="MathJax-Span-380" class="mi">o</span><span id="MathJax-Span-381" class="mi">s</span><span id="MathJax-Span-382" class="mi">t</span><span id="MathJax-Span-383" class="mi">M</span><span id="MathJax-Span-384" class="mi">i</span><span id="MathJax-Span-385" class="mi">n</span><span id="MathJax-Span-386" class="mo">(</span><span id="MathJax-Span-387" class="mi">i</span><span id="MathJax-Span-388" class="mo">,</span><span id="MathJax-Span-389" class="mi">j</span><span id="MathJax-Span-390" class="mo">,</span><span id="MathJax-Span-391" class="mi">k</span><span id="MathJax-Span-392" class="mo">&minus;</span><span id="MathJax-Span-393" class="mn">1</span><span id="MathJax-Span-394" class="mo">)</span><span id="MathJax-Span-395" class="mo">,</span><span id="MathJax-Span-396" class="mi">c</span><span id="MathJax-Span-397" class="mi">o</span><span id="MathJax-Span-398" class="mi">s</span><span id="MathJax-Span-399" class="mi">t</span><span id="MathJax-Span-400" class="mi">M</span><span id="MathJax-Span-401" class="mi">i</span><span id="MathJax-Span-402" class="mi">n</span><span id="MathJax-Span-403" class="mo">(</span><span id="MathJax-Span-404" class="mi">i</span><span id="MathJax-Span-405" class="mo">,</span><span id="MathJax-Span-406" class="mi">k</span><span id="MathJax-Span-407" class="mo">,</span><span id="MathJax-Span-408" class="mi">k</span><span id="MathJax-Span-409" class="mo">&minus;</span><span id="MathJax-Span-410" class="mn">1</span><span id="MathJax-Span-411" class="mo">)</span><span id="MathJax-Span-412" class="mo">+</span><span id="MathJax-Span-413" class="mi">c</span><span id="MathJax-Span-414" class="mi">o</span><span id="MathJax-Span-415" class="mi">s</span><span id="MathJax-Span-416" class="mi">t</span><span id="MathJax-Span-417" class="mi">M</span><span id="MathJax-Span-418" class="mi">i</span><span id="MathJax-Span-419" class="mi">n</span><span id="MathJax-Span-420" class="mo">(</span><span id="MathJax-Span-421" class="mi">k</span><span id="MathJax-Span-422" class="mo">,</span><span id="MathJax-Span-423" class="mi">j</span><span id="MathJax-Span-424" class="mo">,</span><span id="MathJax-Span-425" class="mi">k</span><span id="MathJax-Span-426" class="mo">&minus;</span><span id="MathJax-Span-427" class="mn">1</span><span id="MathJax-Span-428" class="mo">)</span><span id="MathJax-Span-429" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,j,k)=min(costMin(i,j,k&minus;1),costMin(i,k,k&minus;1)+costMin(k,j,k&minus;1))</span></span>.</p>
                <p>Această formulă este cheia algoritmului Roy-Floyd. Algoritmul determină mai &icirc;nt&acirc;i&nbsp;<span id="MathJax-Element-41-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-430" class="math"><span id="MathJax-Span-431" class="mrow"><span id="MathJax-Span-432" class="mi">c</span><span id="MathJax-Span-433" class="mi">o</span><span id="MathJax-Span-434" class="mi">s</span><span id="MathJax-Span-435" class="mi">t</span><span id="MathJax-Span-436" class="mi">M</span><span id="MathJax-Span-437" class="mi">i</span><span id="MathJax-Span-438" class="mi">n</span><span id="MathJax-Span-439" class="mo">(</span><span id="MathJax-Span-440" class="mi">i</span><span id="MathJax-Span-441" class="mo">,</span><span id="MathJax-Span-442" class="mi">j</span><span id="MathJax-Span-443" class="mo">,</span><span id="MathJax-Span-444" class="mn">1</span><span id="MathJax-Span-445" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,j,1)</span></span>, pentru toate perechile&nbsp;<span id="MathJax-Element-42-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-446" class="math"><span id="MathJax-Span-447" class="mrow"><span id="MathJax-Span-448" class="mi">i</span><span id="MathJax-Span-449" class="mo">,</span><span id="MathJax-Span-450" class="mi">j</span></span></span><span class="MJX_Assistive_MathML">i,j</span></span>, apoi&nbsp;<span id="MathJax-Element-43-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-451" class="math"><span id="MathJax-Span-452" class="mrow"><span id="MathJax-Span-453" class="mi">c</span><span id="MathJax-Span-454" class="mi">o</span><span id="MathJax-Span-455" class="mi">s</span><span id="MathJax-Span-456" class="mi">t</span><span id="MathJax-Span-457" class="mi">M</span><span id="MathJax-Span-458" class="mi">i</span><span id="MathJax-Span-459" class="mi">n</span><span id="MathJax-Span-460" class="mo">(</span><span id="MathJax-Span-461" class="mi">i</span><span id="MathJax-Span-462" class="mo">,</span><span id="MathJax-Span-463" class="mi">j</span><span id="MathJax-Span-464" class="mo">,</span><span id="MathJax-Span-465" class="mn">2</span><span id="MathJax-Span-466" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,j,2)</span></span>, apoi&nbsp;<span id="MathJax-Element-44-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15.4px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; color: #c7254e; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-467" class="math"><span id="MathJax-Span-468" class="mrow"><span id="MathJax-Span-469" class="mi">c</span><span id="MathJax-Span-470" class="mi">o</span><span id="MathJax-Span-471" class="mi">s</span><span id="MathJax-Span-472" class="mi">t</span><span id="MathJax-Span-473" class="mi">M</span><span id="MathJax-Span-474" class="mi">i</span><span id="MathJax-Span-475" class="mi">n</span><span id="MathJax-Span-476" class="mo">(</span><span id="MathJax-Span-477" class="mi">i</span><span id="MathJax-Span-478" class="mo">,</span><span id="MathJax-Span-479" class="mi">j</span><span id="MathJax-Span-480" class="mo">,</span><span id="MathJax-Span-481" class="mn">3</span><span id="MathJax-Span-482" class="mo">)</span></span></span><span class="MJX_Assistive_MathML">costMin(i,j,3)</span></span>, etc.</p>
              <h1>Secvență C++</h1>
                <pre style="font-size:20px" class="code_cpp cm-s-default" data-lang="text/x-c++src" contenteditable="true" editable="true"><span class="cm-comment">//D[][] este inițial matricea costurilor arcelor</span>
<span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">k</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">k</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-variable">k</span> <span class="cm-operator">++</span>)
    <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">i</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-variable">i</span> <span class="cm-operator">++</span>)
        <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">j</span> <span class="cm-operator">=</span> <span class="cm-number">1</span> ; <span class="cm-variable">j</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-variable">j</span> <span class="cm-operator">++</span>)
            <span class="cm-keyword">if</span>(<span class="cm-variable">D</span>[<span class="cm-variable">i</span>][<span class="cm-variable">j</span>] <span class="cm-operator">&gt;</span> <span class="cm-variable">D</span>[<span class="cm-variable">i</span>][<span class="cm-variable">k</span>] <span class="cm-operator">+</span> <span class="cm-variable">D</span>[<span class="cm-variable">k</span>][<span class="cm-variable">j</span>])
                <span class="cm-variable">D</span>[<span class="cm-variable">i</span>][<span class="cm-variable">j</span>] <span class="cm-operator">=</span> <span class="cm-variable">D</span>[<span class="cm-variable">i</span>][<span class="cm-variable">k</span>] <span class="cm-operator">+</span> <span class="cm-variable">D</span>[<span class="cm-variable">k</span>][<span class="cm-variable">j</span>];
                </pre>
             </div>


             <div class="textbox" id="AD">
              <p>Algoritmul lui Dijkstra determină pentru un nod dat &icirc;ntr-un graf orientat cu costuri costurile minime ale drumurilor care au acel nod ca extremitate inițială.</p>
              <p>Mai precis, pentru un nod&nbsp;<code>s</code>&nbsp;&ndash;&nbsp;<em>sursă</em>, algoritmul determină pentru orice nod&nbsp;<code>x</code>&nbsp;costul minim al unui drum de la&nbsp;<code>s</code>&nbsp;la&nbsp;<code>x</code>.</p>
              <p>Strategia algoritmului lui Dijkstra este una de tip&nbsp;<em>Greedy</em>:</p>
              <p class="indented">se menține un tablou&nbsp;<code>d[]</code>, &icirc;n care&nbsp;<code>d[x]</code>&nbsp;reprezintă costul minim curent (eventual infinit) al unui drum de la&nbsp;<code>s</code>&nbsp;la&nbsp;<code>x</code>;</p>
              <p class="indented">se menține o mulțime&nbsp;<code>F</code>&nbsp;de noduri&nbsp;<code>k</code>&nbsp;pentru care s-a determinat costul minim final&nbsp;<code>d[k]</code></p>
              <p class="indented">inițial &icirc;n&nbsp;<code>F</code>&nbsp;se adaugă doar nodul&nbsp;<code>s</code>, pentru care&nbsp;<code>d[s]=0</code>; pentru nodurile&nbsp;<code>x</code>&nbsp;adiacente cu&nbsp;<code>s</code>,&nbsp;<code>d[x]=c[s,x]</code>, unde&nbsp;<code>c[x,y]</code>&nbsp;este costul arcului&nbsp;<code>(x,y)</code>, iar pentru celelalte noduri costul&nbsp;<code>d[]</code>&nbsp;se inițializează cu&nbsp;<span class="caps">INFINIT</span>;</p>
              <p class="indented">&icirc;n mod repetat:</p>
              <p class="indented">-alegem un nod din afara mulțimii&nbsp;<code>F</code>, nodul&nbsp;<code>k</code>&nbsp;pentru care costul drumului&nbsp;<code>d[k]</code>&nbsp;este minim și finit;</p>
              <p class="indented">-adăugăm nodul găsit&nbsp;<code>k</code>&nbsp;&icirc;n&nbsp;<code>F</code>;</p>
              <p class="indented">-pentru fiecare arc&nbsp;<code>(k,x)</code>&nbsp;cu&nbsp;<code>x</code>&nbsp;din afara mulțimii&nbsp;<code>F</code>&nbsp;stabilim dacă acest arc se &icirc;mbunătățește costul&nbsp;<code>d[x]</code>&nbsp;(arcul relaxează drumul);</p>
              <img src="dijkstra-drumuri.png">
              <p class="indented">alegerea acestor noduri se termină c&acirc;nd toate nodurile au fost adăugate &icirc;n&nbsp;<code>F</code>&nbsp;(s-au determinat costurile drumurile de la&nbsp;<code>s</code>&nbsp;la fiecare nod al grafului) sau c&acirc;nd nu mai există noduri&nbsp;<code>x</code>&nbsp;din afara mulțimii&nbsp;<code>F</code>&nbsp;pentru care&nbsp;<code>d[x]</code>&nbsp;este finit;</p>
              <h1>Exercițiu</h1>
               <p>Aplicați algoritmul lui Dijkstra pentru graful de mai jos și <code>s=1</code>:</p>
               <img src="dijkstra-0.png">
              <h2>Secvență C++</h2>
               <p>&Icirc;n secvența de mai jos, considerăm un garf orientat cu &icirc;n noduri, reprezentat prin matricea de adiacență&nbsp;<code>a[][]</code>, &icirc;n care&nbsp;<code>a[i][j]=INFINIT</code>&nbsp;dacă nu există arcul&nbsp;<code>(i,j)</code>.</p>
               <pre style="font-size:20px" contenteditable="true" editable="true">#define INFINIT 1000000000
...
//nodul sursa este s
...
for(i =1 ; i &lt;= n ; i ++ )
{
	f[i] = 0;
	d[i] = a[s][i];
}

f[s] = 1, d[s] = 0;
d[0] = INFINIT; // pentru determinarea nodului cu costul minim
for(int k = 1 ; k &lt; n ; ++k)
{
	int pmax = 0;
	for(i = 1 ; i &lt;= n ; ++i)
		if(f[i] == 0 &amp;&amp; d[i] &lt; d[pmax])
			pmax = i;

	if(pmax &gt; -1)
	{
		f[pmax] = 1;
		for(i = 1; i &lt;= n ; ++i)
			if(f[i] == 0 &amp;&amp; d[i] &gt; d[pmax] + a[pmax][i])
				d[i] = d[pmax] + a[pmax][i];
	}
}</pre>
             </div>


             <div class="textbox" id="AP">
              <p>Considerăm un graf neorientat ponderat (cu costuri) conex&nbsp;<code>G</code>. Se numește&nbsp;<strong>arbore parțial</strong>&nbsp;un graf parțial al lui&nbsp;<code>G</code>&nbsp;care este arbore. Se numește&nbsp;<strong>arbore parțial de cost minim</strong>&nbsp;un arbore parțial pentru care suma costurilor muchiilor este minimă.</p>
              <p>Dacă graful nu este conex, vorbim despre o&nbsp;<strong>pădure parțială de cost minim</strong>.</p>
              <p><strong>Algoritmul lui Prim</strong>&nbsp;permite determinarea unui arbore parțial de cost minim (<span class="caps">APM</span>) &icirc;ntr-un graf ponderat cu&nbsp;<code>N</code>&nbsp;noduri.</p>
              <h1>Descrierea algoritmului</h1>
               <p>Determinarea APM-ului se face astfel:</p>
               <p class="indented">se stabilește un nod de plecare; acesta va fi rădăcina arborelui, care se va crea pas cu pas, prin adăugarea de noi noduri;</p>
               <p class="indented">&icirc;n mod repetat:</p>
               <p class="indented">se alege un nod neadăugat &icirc;ncă &icirc;n arborele curent pentru care muchia dintre el și un nod din arbore are cost minim;</p>
               <p class="indented">se adăugă nodul &icirc;n arbore;</p>
               <p class="indented">c&acirc;nd nu se mai poate face alegerea unui asemenea nod, fie au fost adăugate toate nodurile, fie graful nu este conex și au fost adăugate &icirc;n arbore toate nodurile din componenta conexă a nodul inițial;</p>
               <p class="indented">dacă graful nu este conex, continuăm cu următoarea componentă conexă.</p>
               <p><strong>Observație:</strong>&nbsp;arborele parțial de cost minim al unui graf neorientat nu este unic, &icirc;nsă toate&nbsp;<span class="caps">APM</span>-urile vor avea același cost.</p>
             </div>

             <div class="textbox" id="AK">
               <p>Considerăm un graf neorientat ponderat (cu costuri) conex&nbsp;<code>G</code>. Se numește&nbsp;<strong>arbore parțial</strong>&nbsp;un graf parțial al lui&nbsp;<code>G</code>&nbsp;care este arbore. Se numește&nbsp;<strong>arbore parțial de cost minim</strong>&nbsp;un arbore parțial pentru care suma costurilor muchiilor este minimă.</p>
               <p>Dacă graful nu este conex, vorbim despre o&nbsp;<strong>pădure parțială de cost minim</strong>.</p>
               <p><strong>Algoritmul lui Kruskal</strong>&nbsp;permite determinarea unui arbore parțial de cost minim (<span class="caps">APM</span>) &icirc;ntr-un graf ponderat cu&nbsp;<code>N</code>&nbsp;noduri.</p>
               <h1>Descrierea algoritmului</h1>
                <p>Pentru a determina APM-ul se pleacă de la o pădure formată din N subarbori. Fiecare nod al grafului reprezintă inițial un subarbore. Aceștia vor fi reuniți succesiv prin muchii, până când se obține un singur arbore (dacă graful este conex) sau până când acest lucru nu mai este posibil (dacă graful nu este conex).</p>
                <p>Algoritmul este:</p>
                <p class="indented">se ordonează muchiile grafului crescător după cost;</p>
                <p class="indented">se analizează pe rând muchiile grafului, în ordinea crescătoare a costurilor;</p>
                <p class="indented">pentru fiecare muchie analizată:</p>
                <p class="indented">dacă extremitățile muchiei fac parte din același subarbore, muchia se ignoră</p>
                <p class="indented">dacă extremitățile muchiei fac parte din subarbori diferiți, aceștia se vor reuni, iar muchia respectivă face parte din APM.</p>
                <p>Principala dificultate în algoritmul descris mai sus este stabilirea faptului că extremitățile muchiei curente fac sau nu parte din același subarbore. În acest scop vom stabili pentru fiecare subarbore un nod special, numit reprezentant al (sub)arborelui și pentru fiecare nod din graf vom memora reprezentantul său (de fapt al subarborelui din care face parte) într-un tablou unidimensional.</p>
                <p>Pentru a stabili dacă două noduri fac sau nu parte din același subarbore vom verifica dacă ele au același reprezentant. Pentru a reuni doi subarbori vom înlocui pentru toate nodurile din subarborele B cu reprezentantul subarborelui A.</p>
                <p>&Icirc;nlocuirile descrise mai sus sunt simple dar lente. Pentru o implementare mai eficientă a algoritmului se poate folosi conceptul de&nbsp;<strong>Padure de mulțimi disjuncte</strong>, descris &icirc;n&nbsp;<a href="https://www.pbinfo.ro/articole/6024/paduri-de-multimi-disjuncte">acest articol</a>.</p>
               <h1>Secvență C++</h1>
                <p>Următoarea secvență determină costul total al APM-ului, folosind algoritmul lui Kruskal. Presupunem că graful are cel mult 100 de noduri.</p>
                <pre style="font-size:20px"class="code_cpp cm-s-default" data-lang="text/x-c++src" contenteditable="true" editable="true"><span class="cm-keyword">struct</span> <span class="cm-variable">muchie</span>{
    <span class="cm-keyword">int</span> <span class="cm-variable">i</span>,<span class="cm-variable">j</span>,<span class="cm-variable">cost</span>;
};

<span class="cm-keyword">int</span> <span class="cm-variable">n</span> , <span class="cm-variable">m</span> , <span class="cm-variable">t</span>[<span class="cm-number">101</span>];

<span class="cm-variable">muchie</span> <span class="cm-variable">x</span>[<span class="cm-number">5000</span>];

<span class="cm-keyword">int</span> <span class="cm-variable">main</span>()
{
    <span class="cm-variable">cin</span> <span class="cm-operator">&gt;&gt;</span> <span class="cm-variable">n</span> <span class="cm-operator">&gt;&gt;</span> <span class="cm-variable">m</span>;

    <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span> ; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">m</span> ; <span class="cm-operator">++</span><span class="cm-variable">i</span>)
        <span class="cm-variable">cin</span> <span class="cm-operator">&gt;&gt;</span> <span class="cm-variable">x</span>[<span class="cm-variable">i</span>].<span class="cm-variable">i</span> <span class="cm-operator">&gt;&gt;</span> <span class="cm-variable">x</span>[<span class="cm-variable">i</span>].<span class="cm-variable">j</span> <span class="cm-operator">&gt;&gt;</span> <span class="cm-variable">x</span>[<span class="cm-variable">i</span>].<span class="cm-variable">cost</span>;

    <span class="cm-comment">//sortare tablou x[] după campul cost</span>
    <span class="cm-comment">// ... de completat</span>

    <span class="cm-comment">//initializare reprezentanti</span>
    <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span><span class="cm-number">1</span> ; <span class="cm-variable">i</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">i</span>)
        <span class="cm-variable">t</span>[<span class="cm-variable">i</span>] <span class="cm-operator">=</span> <span class="cm-variable">i</span>;
      <span class="cm-comment">//determinare APM</span>
    <span class="cm-keyword">int</span> <span class="cm-variable">S</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>, <span class="cm-variable">cnt</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;
    <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span> ; <span class="cm-variable">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">m</span> <span class="cm-operator">&amp;&amp;</span> <span class="cm-variable">cnt</span> <span class="cm-operator">&lt;</span> <span class="cm-variable">n</span> ; <span class="cm-variable">i</span> <span class="cm-operator">++</span>)
        <span class="cm-keyword">if</span>(<span class="cm-variable">t</span>[<span class="cm-variable">x</span>[<span class="cm-variable">i</span>].<span class="cm-variable">i</span>] <span class="cm-operator">!=</span> <span class="cm-variable">t</span>[<span class="cm-variable">x</span>[<span class="cm-variable">i</span>].<span class="cm-variable">j</span>]) <span class="cm-comment">// extremitatile fac parte din subrabori diferiti</span>
        {
            <span class="cm-variable">S</span> <span class="cm-operator">+=</span> <span class="cm-variable">x</span>[<span class="cm-variable">i</span>].<span class="cm-variable">cost</span>;
            <span class="cm-comment">//reunim subarborii</span>
            <span class="cm-keyword">int</span> <span class="cm-variable">ai</span> <span class="cm-operator">=</span> <span class="cm-variable">t</span>[<span class="cm-variable">x</span>[<span class="cm-variable">i</span>].<span class="cm-variable">i</span>], <span class="cm-variable">aj</span> <span class="cm-operator">=</span> <span class="cm-variable">t</span>[<span class="cm-variable">x</span>[<span class="cm-variable">i</span>].<span class="cm-variable">j</span>];
            <span class="cm-keyword">for</span>(<span class="cm-keyword">int</span> <span class="cm-variable">j</span> <span class="cm-operator">=</span><span class="cm-number">1</span> ; <span class="cm-variable">j</span> <span class="cm-operator">&lt;=</span> <span class="cm-variable">n</span> ; <span class="cm-operator">++</span><span class="cm-variable">j</span>)
                <span class="cm-keyword">if</span>(<span class="cm-variable">t</span>[<span class="cm-variable">j</span>] <span class="cm-operator">==</span> <span class="cm-variable">aj</span>)
                    <span class="cm-variable">t</span>[<span class="cm-variable">j</span>] <span class="cm-operator">=</span> <span class="cm-variable">ai</span>;
        }
    <span class="cm-variable">cout</span> <span class="cm-operator">&lt;&lt;</span> <span class="cm-variable">S</span> <span class="cm-operator">&lt;&lt;</span> <span class="cm-string">"\n"</span>;
    <span class="cm-keyword">return</span> <span class="cm-number">0</span>;
}</pre>
             </div>


             <div class="textbox" id="AR">
              <h1>Arbore liber</h1>
               <p>Un arbore este un graf conex și aciclic. Se mai numește și&nbsp;<strong>arbore liber</strong>.</p>
               <p>Următoarele propoziții sunt adevărate:</p>
               <p class="indented"><p>Un arbore cu&nbsp;<code>n</code>&nbsp;v&acirc;rfuri are&nbsp;<code>n-1</code>&nbsp;muchii.</p></p>
               <p class="indented">Un arbore este un graf conex și minimal cu această proprietate; dacă s-ar mai elimina o muchie, graful nu ar mai fi conex.</p>
               <p class="indented">Un arbore este un graf aciclic și maximal cu această proprietate; dacă s-ar mai adăuga o muchie, s-ar obține un ciclu.</p>
               <p class="indented">Între oricare două vârfuri ale unui arbore există un lanț elementar unic.</p>
               <img src="arbore-liber.png">
              <h1>Arbori cu rădăcină</h1>
               <p>Pentru un arbore se poate stabili un nod special, numit&nbsp;<strong>rădăcină</strong>. Putem spune că &ldquo;agățăm&rdquo; arborele &icirc;n rădăcină, iar restul nodurilor cad.</p>
               <p>Mai jos avem trei arbori cu rădăcină. Toți pornesc de la arborele de mai sus, dar diferă prin alegerea rădăcinii.</p>
               <img src="arbore-radacina-2.png">
               <img src="arbore-radacina-3.png">
               <img src="arbore-radacina-5.png">
               <h2>Terminologie</h2>
                <p>Fie un arbore cu rădăcina&nbsp;<code>r</code>&nbsp;și&nbsp;<code>x</code>&nbsp;un nod &icirc;n acest arbore. atunci:</p>
                <p class="indented">se numește&nbsp;<strong>ascendent</strong>&nbsp;al lui&nbsp;<code>x</code>&nbsp;orice nod&nbsp;<code>y</code>, diferite de&nbsp;<code>x</code>, aflat pe lanțul de la rădăcină la&nbsp;<code>x</code>;</p>
                <p class="indented">rădăcina nu are ascendenți;</p>
                <p class="indented">rădăcina este ascendent pentru toate nodurile din arbore;</p>
                <p class="indented">dacă&nbsp;<code>y</code>&nbsp;este ascendent al lui&nbsp;<code>x</code>&nbsp;și există muchia&nbsp;<code>(y,x)</code>, atunci&nbsp;<code>y</code>&nbsp;se numește&nbsp;<strong>ascendent direct</strong>&nbsp;al lui&nbsp;<code>x</code>&nbsp;sau&nbsp;<strong>tatăl</strong>&nbsp;lui&nbsp;<code>x</code>;</p>
                <p class="indented">rădăcina este singurul nod din arbore care nu are tată;</p>
                <p class="indented">un nod&nbsp;<code>y</code>&nbsp;este&nbsp;<strong>descendent</strong>&nbsp;al nodului&nbsp;<code>x</code>, diferit de&nbsp;<code>y</code>, dacă&nbsp;<code>x</code>&nbsp;aparține lanțului de la&nbsp;<code>r</code>&nbsp;la&nbsp;<code>y</code>;</p>
                <p class="indented">dacă &icirc;n plus există muchia&nbsp;<code>(x,y)</code>, atunci&nbsp;<code>y</code>&nbsp;este&nbsp;<strong>descendent direct</strong>&nbsp;sau&nbsp;<strong>fiu</strong>&nbsp;al lui&nbsp;<code>x</code>;</p>
                <p class="indented">un nod care nu are niciun descendent se numește&nbsp;<strong>frunză</strong>;</p>
                <p class="indented">două noduri care au același tată se numesc&nbsp;<strong>frați</strong>;</p>
                <p class="indented">lungimea unui lanț de la rădăcina arborelui la un nod&nbsp;<code>x</code>&nbsp;reprezintă&nbsp;<strong>nivelul</strong>&nbsp;sau&nbsp;<strong>ad&acirc;ncimea</strong>&nbsp;nodului&nbsp;<code>x</code>;</p>
                <p class="indented">lungimea maximă a unui lanț de la rădăcină la un nod al arborelui reprezintă&nbsp;<strong>&icirc;nălțimea</strong>&nbsp;arborelui;</p>
                <p class="indented">un nod al arborelui &icirc;mpreună cu toți descendenții săi formează un&nbsp;<strong>subarbore</strong>;</p>
               <h2>Exemplu</h2>
                <p>Fie arborele următor:</p>
                <img src="arbore-radacina.png">
                <p class="indented">rădăcina arborelui este nodul&nbsp;<code>3</code>;</p>
                <p class="indented">ascendenții nodului&nbsp;<code>4</code>&nbsp;sunt&nbsp;<code>5</code>,&nbsp;<code>2</code>&nbsp;și&nbsp;<code>3</code>. Ascendentul direct (tatăl) al nodului&nbsp;<code>4</code>&nbsp;este nodul&nbsp;<code>5</code>;</p>
                <p class="indented">descendenții nodului&nbsp;<code>2</code>&nbsp;sunt&nbsp;<code>1 7 10 5 4 6</code>. Descendenții direcți ai nodului&nbsp;<code>2</code>&nbsp;sunt&nbsp;<code>1 5</code>;</p>
                <p class="indented">nodurile&nbsp;<code>1</code>&nbsp;și&nbsp;<code>5</code>&nbsp;sunt frați;</p>
                <p class="indented">nodurile&nbsp;<code>6 7 8 10 12</code>&nbsp;sunt frunze;</p>
                <p class="indented">descompunerea pe niveluri:</p>
                <p class="indented">Nivelul&nbsp;<code>0</code>&nbsp;conține doar rădăcina:&nbsp;<code>3</code>;</p>
                <p class="indented">Nivelul&nbsp;<code>1</code>&nbsp;conține nodurile&nbsp;<code>2 9</code>;</p>
                <p class="indented">Nivelul&nbsp;<code>2</code>&nbsp;conține nodurile&nbsp;<code>1 5 8 11</code>;</p>
                <p class="indented">Nivelul&nbsp;<code>3</code>&nbsp;conține nodurile&nbsp;<code>7 10 4 12</code>;</p>
                <p class="indented">Nivelul&nbsp;<code>4</code>&nbsp;conține nodul&nbsp;<code>6</code>;</p>
                <p class="indented">&Icirc;nălțimea arborelui este&nbsp;<code>4</code>;</p>
                <p class="indented">Nodurile&nbsp;<code>9 8 11 12</code>&nbsp;formează un subarbore;</p>
               <h2>Reprezentarea arborilor</h2>
               <h2>Reprezentarea prin referințe descendente</h2>
                <p>Pentru fiecare nod al arborelui se memorează informații despre descendenții săi direcți. Este similară cu reprezentarea prin liste de adiacențe a grafurilor. Pentru arborele de mai sus avem:</p>
                <p class="indented">F[1]={7,10}</p>
                <p class="indented">[2]={1,5}</p>
                <p class="indented">F[3]={2,9}</p>
                <p class="indented">F[4]={6}</p>
                <p class="indented">F[5]={4}</p>
                <p class="indented">F[6]={}</p>
                <p class="indented">F[7]={}</p>
                <p class="indented">F[8]={}</p>
                <p class="indented">F[9]={8,11}</p>
                <p class="indented">F[10]={}</p>
                <p class="indented">F[11]={12}</p>
                <p class="indented">[12]={}</p>
               <h2>Reprezentarea prin referințe ascendente</h2>
                <p>Pentru fiecare nod se memorează informații despre ascendenții direcți. Vom obține un&nbsp;<strong>vector de tați</strong>, &icirc;n care:</p>
                <p class="indented"><code>t[r] = 0</code>, unde&nbsp;<code>r</code>&nbsp;este rădăcina arborelui</p>
                <p class="indented"><code>t[k] = </code>&nbsp;tatăl nodului&nbsp;<code>k</code></p>
                <p>Pentru arborele de mai sus avem:</p>
                <table class="table">
		             <tbody>
                  <tr>
			            <td>   <code>k</code> </td>
			            <td> <code>1</code> </td>
			            <td> <code>2</code> </td>
			            <td> <code>3</code> </td>
			            <td> <code>4</code> </td>
			            <td> <code>5</code> </td>
			            <td> <code>6</code> </td>
			            <td> <code>7</code> </td>
                  <td> <code>8</code> </td>
			            <td> <code>9</code> </td>
			            <td> <code>10</code> </td>
			            <td> <code>11</code> </td>
			            <td> <code>12</code> </td>
		              </tr>
		              <tr>
			             <td> <code>t[k]</code></td>
			             <td> <code>2</code> </td>
			             <td> <code>3</code> </td>
		               <td> <code>0</code> </td>
			             <td> <code>5</code> </td>
			             <td> <code>2</code> </td>
			             <td> <code>4</code> </td>
			             <td> <code>1</code> </td>
			             <td> <code>9</code> </td>
			             <td> <code>3</code> </td>
			             <td> <code>1</code>  </td>
			             <td> <code>9</code>  </td>
			             <td> <code>11</code> </td>
		              </tr>
                 </tbody>
                </table>
                <p>Observații</p>
                <p class="indented">&Icirc;n vectorul de tați există o singură valoare&nbsp;<code>0</code>, corespunzătoare rădăcinii;</p>
                <p class="indented">Frunzele corespund valorilor care nu apar &icirc;n vectorul de tați.</p>
                <p class="indented">Vectorul de tați ne permite să determinăm lanțuri &icirc;n arbore, de la un nod oarecare spre rădăcină:</p>
                <p class="indented">Pornim de la un nod dat&nbsp;<code>x</code></p>
                <p class="indented">Identificăm tatăl lui&nbsp;<code>x</code>,&nbsp;<code>y = t[x]</code>;</p>
                <p class="indented">Identificăm tatăl lui&nbsp;<code>y</code>,&nbsp;<code>t[y]</code></p>
                <p class="indented">ș.a.m.d.</p>
                <p class="indented">Ajungem &icirc;ntr-un nod&nbsp;<code>z</code>&nbsp;pentru care&nbsp;<code>t[z]=0</code>. acesta va fi rădăcina și ne oprim.</p>
             </div>


           </section>

           <!-- Footer-ul -->
           <section class="footer">
             <div class="footer-a"><a>Copyright &copy; 2020 Socea Teodor</a>
             </div>
           </section>
         </div>
       </div>
    </body>
</html>
